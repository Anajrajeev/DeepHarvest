{
  "url": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API",
  "content": {
    "text": {
      "title": "Using the Web Animations API - Web APIs | MDN",
      "text": "Using the Web Animations API - Web APIs | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all\u2026 HTML guides Responsive images HTML cheatsheet Date & time formats See all\u2026 Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values See all\u2026 CSS guides Box model Animations Flexbox Colors See all\u2026 Layout cookbook Column layouts Centering an element Card component See all\u2026 JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all\u2026 JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all\u2026 Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all\u2026 Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all\u2026 Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started modules Core modules MDN Curriculum Learn HTML Structuring content with HTML module Learn CSS CSS styling basics module CSS layout module Learn JavaScript Dynamic scripting with JavaScript module Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Web Web APIs Web Animations API Using the Web Animations API Using the Web Animations API The Web Animations API lets us construct animations and control their playback with JavaScript. This article will start you off in the right direction with fun demos and tutorials featuring Alice in Wonderland. In this article Meet the Web Animations API Writing CSS Animations with the Web Animations API Controlling playback with play(), pause(), reverse(), and updatePlaybackRate() Persisting animation styles Automatically removing filling animations Getting information out of animations Callbacks and promises Conclusion See also Meet the Web Animations API The Web Animations API opens the browser's animation engine to developers and manipulation by JavaScript. This API was designed to underlie implementations of both CSS Animations and CSS Transitions , and leaves the door open to future animation effects. It is one of the most performant ways to animate on the Web, letting the browser make its own internal optimizations without hacks, coercion, or Window.requestAnimationFrame() . With the Web Animations API, we can move interactive animations from stylesheets to JavaScript, separating presentation from behavior. We no longer need to rely on DOM-heavy techniques such as writing CSS properties and scoping classes onto elements to control playback direction. And unlike pure, declarative CSS, JavaScript also lets us dynamically set values from properties to durations. For building custom animation libraries and creating interactive animations, the Web Animations API might be the perfect tool for the job. Let's see what it can do! This page contains a suite of examples utilizing the Web Animations API , inspired by Alice in Wonderland . These examples are created by and shared at the courtesy of Rachel Nabors . The full suite of examples are available on CodePen; here we present the ones relevant for our docs. Writing CSS Animations with the Web Animations API One of the more familiar ways to approach learning the Web Animations API is to start with something most web developers have played with before: CSS Animations. CSS Animations have a familiar syntax that breaks down nicely for demonstration purposes. The CSS version Here's a tumbling animation written in CSS showing Alice falling down the rabbit hole that leads to Wonderland: <div class=\"wrapper\">\n  <div id=\"tunnel\"></div>\n  <div id=\"alice\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\">\n      <path\n        d=\"M110.1 2.7h8.9c3.4.4 6.7.8 10.1 1.3 9.8 1.5 17.8 6.4 24.5 13.7.4.5 1.9.6 2.5.3 6.8-4.4 13.9-8.2 21.9-9.9 1.3-.3 3.4-1.2 3.7 1.5.6 4.9 1.4 9.9 1.7 14.8.3 4.4.1 8.7.1 12.2 2.1 1.5 4.6 2.3 5.5 4 4.2 8.4 3.2 17.6 3.1 26.6 0 1.2-.4 3.3.1 3.6 10.3 4.9 20.7 9.6 31.1 14.4 2.5-4.9-2.3-16-15.8-14.4.6-.5 1.4-1.1 2.2-1.1 2.5.1 4.9.4 7.4.7 6 .8 10.9 3.7 14.6 8.4 1.2 1.5 1.6 4.2 1.1 6.1-.7 3.2-3.7 4-7.1 4.1 4.5 3.5 6.5 8.1 6.8 13.3.6 9.4-1.1 18.6-4.8 27.1-3.9 8.8-5.2 17.5-3.3 26.8.6 3.2 1.2 7 .2 9.9-2 6.2-7.8 8.6-13.4 10.9-3 1.2-7.4 1.2-6.3 6.3.8 3.7-.4 4 .2 4.5 5.8 5.8 11.8 11.5 17.6 17.3 1.7 1.7 3 3.8 4.3 5.5-1.1.4-1.8.7-2.4 1 7.5 5.8 14.9 11.6 22.4 17.4 4.3-4.3 8.6-9 13.3-13.2 8.1-7.3 16.7-14 24.5-21.7 3.3-3.3 4.9-8.2 7.4-12.3.3-.4 1.3-.9 1.6-.7 4.6 2.7 6.8 7.2 7.9 12.1 1.3 5.7 1.6 11.6 2.3 17.1 4.2-.2 8.8-.8 13.4-.4 2 .1 4.6 1.8 5.5 3.5 2.2 4.3 3.8 8.9 5.3 13.5 3.7 11.5 6.9 23.2 10.7 34.7 1.7 5.1 3.4 10.4 8.6 13.4.5.3.5 2.7 0 3.1-3.3 2.5-6.9 4.6-10.5 7 2 5.8 4.3 12.6 6.7 19.6.7-.8 1.4-1.6 2.1-2.3 1.9-1.9 3.5-1.6 4.2 1.2.7 3 1.3 6.2 1.5 9.3.3 7.3.4 14.6.6 21.9 0 .4.2.8.5 1.2 3.6 4.7 7.1 9.3 10.7 14 1.7 2.3 3 5.4 5.3 6.6 5.5 2.7 11.5 4.4 17.3 6.6v.7c-.4.3-.7.8-1.2 1-5.8 2.1-11.6 4.3-17.5 6.2-4.2 1.3-8.4 2-12.4-1.2-1.8-1.5-3.9-2.6-5.8-3.8 0 2.3.1 4.4-.1 6.4-.1.8-.7 2.2-1.2 2.2-2.6.2-5.3.1-7.9.1-1.1 0-2.7.3-3.2-.3-1-1.2-2.1-2.9-2.1-4.4-.1-5.2.1-10.4.3-15.6.1-1.8 1.5-3.9.9-5.4-1.7-4.3-4-8.4-6.1-12.5-2.4-4.6-6.4-9.1-1.2-14.3.3-.3.3-1.3 0-1.7-4.7-6.5-9.5-13.1-14.4-19.5-1.2-1.5-2.9-3.7-4.4-3.7-6.7.1-13.4.8-20.1 1.3-.7.1-1.6.2-1.9.6-7.1 9.1-14 18.3-21.1 27.4-1.3 1.7-2.9 3.4-4.3 5 1.7.6 3.3 1.1 4.8 1.7.6.2 1.3.5 1.6 1 .2.3-.1 1.1-.4 1.5-2 2.6-4.1 5.2-6.1 7.8-4.3 5.3-8.7 10.5-13 15.9-.8 1-1.5 2.4-1.6 3.6-.2 5.4-.1 10.7-.1 16.1 0 1.5-.7 3.6.1 4.5 2.4 3 5.3 5.5 7.9 8.2 1.6 1.7 3 3.5 4.6 5.5-2.6.2-4.5.3-6.4.4h-3.7c-4.8-1.4-9.8-2.5-14.5-4.3-3.5-1.4-7.8-2.5-8-7.7-.1-2.1-.2-4.3-.4-6.7-1 1.1-1.7 2.1-2.6 2.9-.3.3-1 .4-1.3.2-1.9-1.1-3.7-2.2-5.5-3.4-1.7-1.1-4.5-1.6-3.5-4.5 2.3-6.5 6.4-11.6 12.7-14.9.6-.3 1.3-.9 1.6-1.5 3.9-8.2 7.8-16.4 11.8-24.6.7-1.5.4-4.5 3.8-3.8.2.1 1.2-3.1 1.8-4.9-2.8 1.5-5 2.9-7.4 3.9-7.4 3-14.7 6.4-23.1 5.6-8.5-.7-16.2-3.4-23.2-8-9.9-6.7-14.2-17-17.5-27.9-.5-1.7-.5-5.1-3.5-1.6-.1.2-.4.2-.6.3-2.5 1.7-5.4 3-6 6.5-.4 2.3-1 4.6-1.5 7-2.9 13.2-4.2 26.4-2.5 39.9 1.7 13.1 9.2 21.3 21 26.3 2.4 1 4.9 1.9 7.5 2.9-2.1.9-3.9 1.9-5.8 2.3-10.2 2.5-20.5 4.9-30.8 7.1-1.9.4-4.9.7-5.9-.3-6.4-6.5-8.9-14.8-8.3-23.7.7-9.6 2.1-19.2 3.9-28.6 2.2-11.5 6.1-22.5 11.7-32.9.7-1.3 2-3.1 1.6-4.1-1.8-4.6-4.5-8.9-6.2-13.6-2-5.7-4.2-11.6-1.2-17.8.1-.1-.3-.5-.5-.8 7.6.7 12.8 5.3 17.7 10.2-1.3-8.5-2.6-17.2-3.9-25.8 0-.3-.2-.7-.4-.9-6.7-5.5-13.3-11.2-17-19.2-2.6-5.7-4.3-11.8-6.3-17.7-.6-1.6.2-3.4-2.2-4.8-5.9-3.5-10.3-8.6-10.3-16 0-1.8 1.2-5 2.2-5.1 8.3-1.2 16.4-.1 23.8 4.2 2.4 1.4 4.9 2.7 8.1 4.4-.4-8.8-.8-16.2-1.2-23.6-4.2.9-8.6.9-11.5-2-3.3-3.3-5.4-7.8-7.9-11.8-1.1-1.7-2-3.6-3.5-6.4-3.8 10.3-7.4 19.9-10.8 29.1-.3-.6-1.1-1.7-1.5-2.9-3.5-10-2.8-20.2-1.1-30.3 1.2-7.4 4.3-14.6 3.1-22.4-.2-1.1.2-2.3.3-3.4-22.1 17.6-38.8 38.4-42.9 67.4-4 28-2.8 54.8 13.5 79.1-36.3-13.8-53-48.6-58.3-84.1-3 8-15 16.3-22.4 16.6v-.2c2.1-2.9 11.1-10.6 7-30.2-1.3-10.7-4.1-21.2-5.1-31.9-1-10.9-1-21.9-.5-32.9.3-11.6 3.8-22.7 8.6-33.2 5.7-12.5 13.5-23.8 23-33.6 5.6-5.8 11.9-11 18.2-16.1 8.6-6.8 17.7-12.9 28.2-16.5 5.1-1.9 10.4-3 15.7-4.5zm96.4 221.9c-.4.9-1.2 2-1.1 3 .5 7.6 1.2 15.2 2 22.7.2 2.1 0 4.8 3.3 5.5 3.3.7 6.6 1.8 9.9 2.6.3.1.9-.1 1.1-.4 3.8-4.8 7.5-9.6 10.9-14-8.4-6.1-17.1-12.6-26.1-19.4zm-23.1-42.5v6.3c1.9-2 3.6-3.9 5.3-5.7-1.7-.2-3.5-.4-5.3-.6z\" />\n    </svg>\n  </div>\n</div> Notice that the background moves, Alice spins, and her color changes at an offset from her spinning. We're going to focus on just Alice for this tutorial. You can check the full source code by clicking \"Play\" on the code block. Here's the simplified CSS that controls Alice's animation: css #alice {\n  animation: alice-tumbling infinite 3s linear;\n}\n\n@keyframes alice-tumbling {\n  0% {\n    color: black;\n    transform: rotate(0) translate3d(-50%, -50%, 0);\n  }\n  30% {\n    color: #431236;\n  }\n  100% {\n    color: black;\n    transform: rotate(360deg) translate3d(-50%, -50%, 0);\n  }\n} #tunnel {\n  animation: tunnel-fly 1s linear infinite;\n}\n\n@keyframes tunnel-fly {\n  100% {\n    transform: translate3d(0, -300px, 0);\n  }\n} #alice {\n  color: #431236;\n  width: 25%;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform-origin: 0 0;\n  transform: rotate(0) translate3d(-50%, -50%, 0);\n  backface-visibility: hidden;\n  will-change: transform, color;\n}\n\npath {\n  fill: currentColor;\n}\n\n#tunnel {\n  background:\n    url(\"/shared-assets/images/examples/web-animations/bg-tunnel-border-left.svg\")\n      repeat-y,\n    url(\"/shared-assets/images/examples/web-animations/bg-tunnel-border-right.svg\")\n      repeat-y 100% 100%,\n    url(\"/shared-assets/images/examples/web-animations/bg-tunnel-specks.png\"),\n    #6c373f;\n  margin: 0 auto;\n  height: calc(100% + 300px);\n  width: 60%;\n  min-width: 400px;\n  backface-visibility: hidden;\n  will-change: transform;\n}\n\n.wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\nbody {\n  background: black;\n}\n\nhtml,\nbody {\n  height: 100%;\n} This changes Alice's color and her transform's rotation over 3 seconds at a constant (linear) rate and loops infinitely. In the @keyframes block we can see that 30% of the way through each loop (about .9 seconds in), Alice's color changes from black to a deep burgundy then back again by the end of the loop. Moving it to JavaScript Now let's try creating the same animation with the Web Animations API. Representing keyframes The first thing we need is to create a Keyframe Object corresponding to our CSS @keyframes block: js const aliceTumbling = [\n  { transform: \"rotate(0) translate3d(-50%, -50%, 0)\", color: \"black\" },\n  { color: \"#431236\", offset: 0.3 },\n  { transform: \"rotate(360deg) translate3d(-50%, -50%, 0)\", color: \"black\" },\n]; Here we're using an array containing multiple objects. Each object represents a key from the original CSS. However, unlike CSS, the Web Animations API doesn't need to explicitly be told the percentages along the animation for each key to appear at. It will automatically divide the animation into equal parts based on the number of keys you give it. This means that a Keyframe object with three keys will play the middle key 50% of the way through each loop of the animation unless told otherwise. When we want to explicitly set a key's offset from the other keys, we can specify an offset directly in the object, separated from the declaration with a comma. In the above example, to make sure that Alice's color changes at 30% (not 50%) for the color change, we are giving it offset: 0.3 . Currently, there should be at least two keyframes specified (representing the starting and ending states of the animation sequence). If your keyframe list has only one entry, Element.animate() may throw a NotSupportedError DOMException in some browsers until they are updated. So to recap, the keys are equally spaced by default unless you specify an offset on a key. Handy, no? Representing timing properties We'll also need to create an object of timing properties corresponding to the values in Alice's animation: js const aliceTiming = {\n  duration: 3000,\n  iterations: Infinity,\n}; You'll notice a few differences here from how equivalent values are represented in CSS: For one, the duration is in milliseconds as opposed to seconds \u2014 3000 not 3s. Like setTimeout() and Window.requestAnimationFrame() , the Web Animations API only takes milliseconds. The other thing you'll notice is that it's iterations , not iteration-count . Note: There are a number of small differences between the terminology used in CSS Animations and the terminology used in Web Animations. For instance, Web Animations doesn't use the string \"infinite\" , but instead uses the JavaScript keyword Infinity . And instead of timing-function we use easing . We aren't listing an easing value here because, unlike CSS Animations where the default animation-timing-function is ease , in the Web Animations API the default easing is linear \u2014 which is what we want here. Bring the pieces together Now it's time to bring them both together with the Element.animate() method: js document.getElementById(\"alice\").animate(aliceTumbling, aliceTiming); And boom: the animation starts playing: document\n  .getElementById(\"tunnel\")\n  .animate(\n    [\n      { transform: \"translate3d(0, 0, 0)\" },\n      { transform: \"translate3d(0, -300px, 0)\" },\n    ],\n    {\n      duration: 1000,\n      iterations: Infinity,\n    },\n  ); The animate() method can be called on any DOM element that could be animated with CSS. And it can be written in several ways. Instead of making objects for keyframes and timing properties, we could just pass their values in directly, like so: js document.getElementById(\"alice\").animate(\n  [\n    { transform: \"rotate(0) translate3d(-50%, -50%, 0)\", color: \"black\" },\n    { color: \"#431236\", offset: 0.3 },\n    { transform: \"rotate(360deg) translate3d(-50%, -50%, 0)\", color: \"black\" },\n  ],\n  {\n    duration: 3000,\n    iterations: Infinity,\n  },\n); What's more, if we only wanted to specify the duration of the animation and not its iterations (by default, animations iterate once), we could pass in the milliseconds alone: js document.getElementById(\"alice\").animate(\n  [\n    { transform: \"rotate(0) translate3d(-50%, -50%, 0)\", color: \"black\" },\n    { color: \"#431236\", offset: 0.3 },\n    { transform: \"rotate(360deg) translate3d(-50%, -50%, 0)\", color: \"black\" },\n  ],\n  3000,\n); Controlling playback with play(), pause(), reverse(), and updatePlaybackRate() While we can write CSS Animations with the Web Animations API, where the API really comes in handy is manipulating the animation's playback. The Web Animations API provides several useful methods for controlling playback. Let's take a look at pausing and playing animations in the Follow the White Rabbit example: In this example, the white rabbit has an animation that causes it to go down a rabbit hole. It's only triggered when the user clicks on it. <div class=\"wrapper\">\n  <div class=\"page\">\n    <div class=\"background\"></div>\n    <div id=\"rabbit\">Click the rabbit's ears!</div>\n    <div class=\"foreground\"></div>\n    <p>\n      She was just in time to see him pop down a hole between a great tree's\n      roots.\n    </p>\n  </div>\n</div> #rabbit {\n  background: url(\"/shared-assets/images/examples/web-animations/park5_rabbit.png\")\n    0 0 / 100% 100%;\n  cursor: pointer;\n  position: absolute;\n  top: 15%;\n  left: 60%;\n  width: 14.64844%;\n  padding-top: 31.00586%;\n}\n\nbody {\n  background: black;\n}\n.wrapper {\n  max-width: 133.33vh;\n  margin: 0 auto;\n}\n.page {\n  background: #431236;\n  height: 0;\n  overflow: hidden;\n  padding-top: 75%;\n  position: relative;\n  text-indent: 100%;\n  white-space: nowrap;\n}\n\n.foreground {\n  height: 100%;\n  background: url(\"/shared-assets/images/examples/web-animations/bg_park5_2.png\")\n    no-repeat 100% 100% / 100% auto;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  pointer-events: none;\n}\n\n.background {\n  background: url(\"/shared-assets/images/examples/web-animations/bg_park5_1.png\")\n    no-repeat 0 0 / 100% auto;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n} Pausing and playing animations We can animate the rabbit using the animate() method as usual: js const whiteRabbit = document.getElementById(\"rabbit\");\n\nconst rabbitDownAnimation = whiteRabbit.animate(\n  [{ transform: \"translateY(0%)\" }, { transform: \"translateY(100%)\" }],\n  { duration: 3000, fill: \"forwards\" },\n); The Element.animate() method will immediately run after it is called. To prevent the cake from eating itself up before the user has had the chance to click on it, we call Animation.pause() on it immediately after it is defined, like so: js rabbitDownAnimation.pause(); Note: Alternatively, you can define rabbitDownAnimation using the Animation() constructor instead, which doesn't start playing until you call play() . We can now use the Animation.play() method to run it whenever we're ready. Specifically, we want to link it to a clicking action. We can achieve this via the following: js whiteRabbit.addEventListener(\"click\", downHeGoes);\nwhiteRabbit.addEventListener(\"touchstart\", downHeGoes);\n\nfunction downHeGoes(event) {\n  whiteRabbit.removeEventListener(\"click\", downHeGoes);\n  whiteRabbit.removeEventListener(\"touchstart\", downHeGoes);\n\n  rabbitDownAnimation.play();\n} When a user clicks or presses their finger on the rabbit, we can now call downHeGoes to make all the animations play. Other useful methods In addition to pausing and playing, we can use the following Animation methods: Animation.finish() skips to the end of the animation. Animation.cancel() aborts the animation and removes its effects. Animation.reverse() sets the animation's playback rate ( Animation.playbackRate ) to a negative value so it runs backward. Let's take a look at playbackRate first \u2014 a negative playbackRate will cause an animation to run in reverse.\nIn Through the Looking-Glass , Alice travels to a world where she must run to stay in place \u2014 and run twice as fast to move forward! In the Red Queen's Race example, Alice and the Red Queen are running to stay in place: <div class=\"wrapper\">\n  <div class=\"sky\"></div>\n  <div class=\"earth\">\n    <div id=\"red-queen-and-alice\">\n      <img\n        id=\"red-queen-and-alice-sprite\"\n        src=\"/shared-assets/images/examples/web-animations/sprite_running-alice-queen_small.png\"\n        srcset=\"\n          /shared-assets/images/examples/web-animations/sprite_running-alice-queen.png 2x\n        \"\n        alt=\"Alice and the Red Queen running to stay in place.\" />\n    </div>\n  </div>\n  <div class=\"scenery\" id=\"foreground1\">\n    <img\n      id=\"palm3\"\n      src=\"/shared-assets/images/examples/web-animations/palm3_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/palm3.png 2x\"\n      alt=\"\" />\n  </div>\n  <div class=\"scenery\" id=\"foreground2\">\n    <img\n      id=\"bush\"\n      src=\"/shared-assets/images/examples/web-animations/bush_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/bush.png 2x\"\n      alt=\"\" />\n    <img\n      id=\"w_rook_upright\"\n      src=\"/shared-assets/images/examples/web-animations/w_rook_upright_small.png\"\n      srcset=\"\n        /shared-assets/images/examples/web-animations/w_rook_upright.png 2x\n      \"\n      alt=\"\" />\n  </div>\n  <div class=\"scenery\" id=\"background1\">\n    <img\n      id=\"r_pawn_upright\"\n      src=\"/shared-assets/images/examples/web-animations/r_pawn_upright_small.png\"\n      srcset=\"\n        /shared-assets/images/examples/web-animations/r_pawn_upright.png 2x\n      \"\n      alt=\"\" />\n    <img\n      id=\"w_rook\"\n      src=\"/shared-assets/images/examples/web-animations/w_rook_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/w_rook.png 2x\"\n      alt=\"\" />\n    <img\n      id=\"palm1\"\n      src=\"/shared-assets/images/examples/web-animations/palm1_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/palm1.png 2x\"\n      alt=\"\" />\n  </div>\n  <div class=\"scenery\" id=\"background2\">\n    <img\n      id=\"r_pawn\"\n      src=\"/shared-assets/images/examples/web-animations/r_pawn_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/r_pawn.png 2x\"\n      alt=\"\" />\n\n    <img\n      id=\"r_knight\"\n      src=\"/shared-assets/images/examples/web-animations/r_knight_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/r_knight.png 2x\"\n      alt=\"\" />\n    <img\n      id=\"palm2\"\n      src=\"/shared-assets/images/examples/web-animations/palm2_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/palm2.png 2x\"\n      alt=\"\" />\n  </div>\n</div> * {\n  user-select: none;\n}\n\nimg {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.scenery {\n  width: 100%;\n  height: 50%;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n}\n\n#foreground1,\n#foreground2 {\n  z-index: 1;\n}\n\n#foreground2,\n#background2 {\n  transform: translateX(100%);\n}\n\n#palm3 {\n  top: 0;\n  left: 10%;\n}\n\n#w_rook_upright {\n  top: 30%;\n  left: 75%;\n}\n\n#r_pawn {\n  top: 10%;\n  left: 15%;\n}\n\n#w_rook {\n  top: 10%;\n  left: 80%;\n}\n\n#r_pawn_upright {\n  top: 5%;\n  left: 30%;\n}\n\n#r_knight {\n  top: 0;\n  left: 70%;\n}\n\n#palm2 {\n  top: -15%;\n  left: 90%;\n}\n\n#palm1 {\n  top: -15%;\n  left: 40%;\n}\n\n#bush {\n  top: 55%;\n  left: 20%;\n}\n\n#red-queen-and-alice {\n  position: absolute;\n  top: 0;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  overflow: hidden;\n  width: 80%;\n  max-width: 450px;\n  z-index: 1;\n}\n\n#red-queen-and-alice::before {\n  content: \" \";\n  display: block;\n  padding-top: 87%;\n}\n\n#red-queen-and-alice img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n}\n\n.sky,\n.earth {\n  position: absolute;\n  left: 0;\n  height: 50vh;\n  width: 100%;\n}\n\n.earth {\n  background: #eb125d\n    url(\"/shared-assets/images/examples/web-animations/bg_earth.jpg\") repeat-x 0\n    0 / 100% auto;\n  bottom: 0;\n}\n\n.sky {\n  background: #246e89\n    url(\"/shared-assets/images/examples/web-animations/bg_sky.jpg\") repeat-x\n    100% 100% / auto 100%;\n  top: 0;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100%;\n}\n\n.wrapper {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n} const background1 = document.getElementById(\"background1\");\nconst background2 = document.getElementById(\"background2\");\n\nconst foreground1 = document.getElementById(\"foreground1\");\nconst foreground2 = document.getElementById(\"foreground2\");\n\nconst redQueenAliceSprite = document.getElementById(\n  \"red-queen-and-alice-sprite\",\n);\n\n/* Background animations */\nconst sceneryFrames = [\n  { transform: \"translateX(100%)\" },\n  { transform: \"translateX(-100%)\" },\n];\n\nconst sceneryTimingBackground = {\n  duration: 36000,\n  iterations: Infinity,\n};\n\nconst sceneryTimingForeground = {\n  duration: 12000,\n  iterations: Infinity,\n};\n\nconst background1Movement = background1.animate(\n  sceneryFrames,\n  sceneryTimingBackground,\n);\nbackground1Movement.currentTime =\n  background1Movement.effect.getComputedTiming().duration / 2;\n\nconst background2Movement = background2.animate(\n  sceneryFrames,\n  sceneryTimingBackground,\n);\n\nconst foreground1Movement = foreground1.animate(\n  sceneryFrames,\n  sceneryTimingForeground,\n);\nforeground1Movement.currentTime =\n  foreground1Movement.effect.getComputedTiming().duration / 2;\n\nconst foreground2Movement = foreground2.animate(\n  sceneryFrames,\n  sceneryTimingForeground,\n);\n\nconst spriteFrames = [\n  { transform: \"translateY(0)\" },\n  { transform: \"translateY(-100%)\" },\n];\n\nconst redQueenAlice = redQueenAliceSprite.animate(spriteFrames, {\n  easing: \"steps(7, end)\",\n  direction: \"reverse\",\n  duration: 600,\n  playbackRate: 1,\n  iterations: Infinity,\n}); Because small children tire out easily, unlike automaton chess pieces, Alice is constantly slowing down. We can do this by setting a decay on her animation's playbackRate . We use updatePlaybackRate() instead of setting the playbackRate directly since that produces a smooth update: js setInterval(() => {\n  // Make sure the playback rate never falls below .4\n  if (redQueenAlice.playbackRate > 0.4) {\n    redQueenAlice.updatePlaybackRate(redQueenAlice.playbackRate * 0.9);\n  }\n  adjustBackgroundPlayback();\n}, 1000); But urging them on by clicking or tapping causes them to speed up by multiplying their playbackRate : js function goFaster() {\n  // But you can speed them up by giving the screen a click or a tap.\n  redQueenAlice.updatePlaybackRate(redQueenAlice.playbackRate * 1.1);\n  adjustBackgroundPlayback();\n}\n\ndocument.addEventListener(\"click\", goFaster);\ndocument.addEventListener(\"touchstart\", goFaster); The background elements also have playbackRate s that are impacted when you click or tap. Their playback rates are derived from Alice's, shown below. What happens when you make Alice and the Red Queen run twice as fast? What happens when you let them slow down? js /* Alice tires so easily! \n  Every so many seconds, reduce their playback rate so they slow a little. \n*/\nconst sceneries = [\n  foreground1Movement,\n  foreground2Movement,\n  background1Movement,\n  background2Movement,\n];\n\nfunction adjustBackgroundPlayback() {\n  // If Alice and the Red Queen are running at a speed of 0.8\u20131.2,\n  // the background doesn't move.\n  // But if they fall under 0.8, the background slides backwards\n  if (redQueenAlice.playbackRate < 0.8) {\n    sceneries.forEach((anim) => {\n      anim.updatePlaybackRate(-redQueenAlice.playbackRate / 2);\n    });\n  } else if (redQueenAlice.playbackRate > 1.2) {\n    sceneries.forEach((anim) => {\n      anim.updatePlaybackRate(redQueenAlice.playbackRate / 2);\n    });\n  } else {\n    sceneries.forEach((anim) => {\n      anim.updatePlaybackRate(0);\n    });\n  }\n}\nadjustBackgroundPlayback(); Persisting animation styles When animating elements, a common use case is to persist the final state of the animation, after the animation has finished. One method sometimes used for this is to set the animation's fill mode to forwards . However, it is not recommended to use fill modes to persist the effect of an animation indefinitely, for two reasons: The browser has to maintain the state of the animation while it is still active, so the animation continues to consume resources even though it is no longer animating. Note that this is somewhat alleviated by the browser automatically removing filling animations . Styles applied by animations have a higher precedence in the cascade than specified styles, so it can be difficult to override them when needed. A better approach is to use the Animation.commitStyles() method. This writes the computed values of the animation's current styles into its target element's style attribute, after which the element can be restyled normally. Automatically removing filling animations It is possible to trigger a large number of animations on the same element. If they are indefinite (i.e., forwards-filling), this can result in a huge animations list, which could create a memory leak. For this reason, browsers automatically remove filling animations after they are replaced by newer animations, unless the developer explicitly specifies to keep them. Animations are removed when all of the following are true: The animation is filling (its fill is forwards if it is playing forwards, backwards if it is playing backwards, or both ). The animation is finished. (Note that because of the fill it will still be in effect.) The animation's timeline is monotonically increasing. (This is always true for DocumentTimeline ; other timelines such as scroll-timeline can run backwards.) The animation is not being controlled by declarative markup such as CSS. Every styling effect of the animation's AnimationEffect is being overridden by another animation that also satisfies all the conditions above. (Typically, when two animations would set the same style property of the same element, the one created last overrides the other.) The first four conditions ensure that, without intervention by JavaScript code, the animation's effect will never change or end. The last condition ensures that the animation will never actually affect the style of any element: it has been entirely replaced. When the animation is automatically removed, the animation's remove event fires. To prevent the browser from automatically removing animations, call the animation's persist() method. The animation's replaceState property will be removed if the animation has been removed, persisted if you have called persist() on the animation, or active otherwise. Getting information out of animations Imagine other ways we could use playbackRate, such as improving accessibility for users with vestibular disorders by letting them slow down animations across an entire site. That's impossible to do with CSS without recalculating durations in every CSS rule, but with the Web Animations API, we could use the Document.getAnimations method to loop over each animation on the page and halve their playbackRate s, like so: js document.getAnimations().forEach((animation) => {\n  animation.updatePlaybackRate(animation.playbackRate * 0.5);\n}); With the Web Animations API, all you need to change is just one little property! Another thing that's tough to do with CSS Animations alone is creating dependencies on values provided by other animations. For instance, in the Growing and Shrinking Alice game example, you might have noticed something odd about the cake's duration: js document.getElementById(\"eat-me-sprite\").animate([], {\n  duration: aliceChange.effect.getComputedTiming().duration / 2,\n}); To understand what's happening here, let's take a look at Alice's animation: js const aliceChange = document\n  .getElementById(\"alice\")\n  .animate(\n    [\n      { transform: \"translate(-50%, -50%) scale(.5)\" },\n      { transform: \"translate(-50%, -50%) scale(2)\" },\n    ],\n    {\n      duration: 8000,\n      easing: \"ease-in-out\",\n      fill: \"both\",\n    },\n  ); Alice's animation has her going from half her size to twice her size over 8 seconds. Then we pause her: js aliceChange.pause(); If we had left her paused at the beginning of her animation, she'd start at half her full size, as if she'd drunk the entire bottle already! We want to set her animation's \"playhead\" in the middle, so she's already halfway done. We could do that by setting her Animation.currentTime to 4 seconds, like so: js aliceChange.currentTime = 4000; But while working on this animation, we might change Alice's duration a lot. Wouldn't it be better if we set her currentTime dynamically, so we don't have to make two updates at a time? We can, in fact, do so by referencing aliceChange's Animation.effect property, which returns an object containing all the details of the effect(s) active on Alice: js aliceChange.currentTime = aliceChange.effect.getComputedTiming().duration / 2; effect lets us access the animation's keyframes and timing properties \u2014 aliceChange.effect.getComputedTiming() points to Alice's timing object \u2014 this contains her duration . We can divide her duration in half to get the midpoint for her animation's timeline, setting her to be normal height. Now we can reverse and play her animation in either direction to make her grow smaller or larger! And we can do the same thing when setting the cake and bottle durations: js const drinking = document\n  .getElementById(\"liquid\")\n  .animate([{ height: \"100%\" }, { height: \"0\" }], {\n    fill: \"forwards\",\n    duration: aliceChange.effect.getComputedTiming().duration / 2,\n  });\ndrinking.pause(); Now all three animations are linked to just one duration, which we can change easily from one place. We can also use the Web Animations API to figure out the animation's current time. The game ends when you run out of cake to eat or empty the bottle. Which vignette players are presented with depends on how far along Alice was in her animation, whether she grew too big and can't get in the tiny door anymore or too small and cannot reach the key to open the door. We can figure out whether she's on the large end or small end of her animation by getting her animation's currentTime and dividing it by her activeDuration : js const endGame = () => {\n  // get Alice's timeline's playhead location\n  const alicePlayhead = aliceChange.currentTime;\n  const aliceTimeline = aliceChange.effect.getComputedTiming().activeDuration;\n\n  // stops Alice's and other animations\n  stopPlayingAlice();\n\n  // depending on which third it falls into\n  const aliceHeight = alicePlayhead / aliceTimeline;\n\n  if (aliceHeight <= 0.333) {\n    // Alice got smaller!\n    // \u2026\n  } else if (aliceHeight >= 0.666) {\n    // Alice got bigger!\n    // \u2026\n  } else {\n    // Alice didn't change significantly\n    // \u2026\n  }\n}; Callbacks and promises CSS Animations and Transitions have their own event listeners, and these are also possible with the Web Animations API: onfinish is the event handler for the finish event and can be triggered manually with finish() . oncancel is the event handler for the cancel event and can be triggers with cancel() . Here we set the callbacks for the cake, bottle, and Alice to fire the endGame function: js // When the cake or bottle runs out\nnommingCake.onfinish = endGame;\ndrinking.onfinish = endGame;\n\n// Alice reaches the end of her animation\naliceChange.onfinish = endGame; Better still, the Web Animations API also provides a finished promise that will resolve when the animation finishes, or reject if it is canceled. Conclusion These are the basic features of the Web Animations API. By now you should be ready to \"jump down the rabbit hole\" of animating in the browser and ready to write your own animation experiments! See also The full suite of Alice in Wonderland demos on CodePen for you to play with, fork, and share. Animating like you just don't care with Element.animate (2016) Explains the background of the Web Animations API and why it is more performant than other web animation methods. Help improve MDN Learn how to contribute This page was last modified on \u2068Nov 7, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content Web Animations API Guides Using the Web Animations API Web Animations API Concepts Keyframe Formats Web animation API tips and tricks Interfaces Animation AnimationEffect AnimationEvent AnimationTimeline AnimationPlaybackEvent DocumentTimeline KeyframeEffect ScrollTimeline ViewTimeline Properties Document .timeline Methods Document .getAnimations() Element .animate() Element .getAnimations() Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation\u2019s not-for-profit parent, the Mozilla Foundation . Portions of this content are \u00a91998\u2013\u20682025\u2069 by individual mozilla.org contributors. Content available under a Creative Commons license .",
      "meta": {
        "viewport": "width=device-width, initial-scale=1.0",
        "description": "The Web Animations API lets us construct animations and control their playback with JavaScript. This article will start you off in the right direction with fun demos and tutorials featuring Alice in Wonderland.",
        "og:url": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API",
        "og:title": "Using the Web Animations API - Web APIs | MDN",
        "og:locale": "en_US",
        "og:description": "The Web Animations API lets us construct animations and control their playback with JavaScript. This article will start you off in the right direction with fun demos and tutorials featuring Alice in Wonderland.",
        "og:image": "https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png",
        "og:image:type": "image/png",
        "og:image:height": "1080",
        "og:image:width": "1920",
        "og:image:alt": "The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background.",
        "og:site_name": "MDN Web Docs",
        "twitter:card": "summary_large_image",
        "twitter:creator": "MozDevNet",
        "position": "4"
      },
      "keywords": [],
      "language": "en",
      "word_count": 4521,
      "description": "The Web Animations API lets us construct animations and control their playback with JavaScript. This article will start you off in the right direction with fun demos and tutorials featuring Alice in Wonderland.",
      "clean_text": "Using the Web Animations API The Web Animations API lets us construct animations and control their playback with JavaScript. This article will start you off in the right direction with fun demos and tutorials featuring Alice in Wonderland. In this article Meet the Web Animations API Writing CSS Animations with the Web Animations API Controlling playback with play(), pause(), reverse(), and updatePlaybackRate() Persisting animation styles Automatically removing filling animations Getting information out of animations Callbacks and promises Conclusion See also Meet the Web Animations API The Web Animations API opens the browser's animation engine to developers and manipulation by JavaScript. This API was designed to underlie implementations of both CSS Animations and CSS Transitions , and leaves the door open to future animation effects. It is one of the most performant ways to animate on the Web, letting the browser make its own internal optimizations without hacks, coercion, or Window.requestAnimationFrame() . With the Web Animations API, we can move interactive animations from stylesheets to JavaScript, separating presentation from behavior. We no longer need to rely on DOM-heavy techniques such as writing CSS properties and scoping classes onto elements to control playback direction. And unlike pure, declarative CSS, JavaScript also lets us dynamically set values from properties to durations. For building custom animation libraries and creating interactive animations, the Web Animations API might be the perfect tool for the job. Let's see what it can do! This page contains a suite of examples utilizing the Web Animations API , inspired by Alice in Wonderland . These examples are created by and shared at the courtesy of Rachel Nabors . The full suite of examples are available on CodePen; here we present the ones relevant for our docs. Writing CSS Animations with the Web Animations API One of the more familiar ways to approach learning the Web Animations API is to start with something most web developers have played with before: CSS Animations. CSS Animations have a familiar syntax that breaks down nicely for demonstration purposes. The CSS version Here's a tumbling animation written in CSS showing Alice falling down the rabbit hole that leads to Wonderland: <div class=\"wrapper\">\n  <div id=\"tunnel\"></div>\n  <div id=\"alice\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 400 400\">\n      <path\n        d=\"M110.1 2.7h8.9c3.4.4 6.7.8 10.1 1.3 9.8 1.5 17.8 6.4 24.5 13.7.4.5 1.9.6 2.5.3 6.8-4.4 13.9-8.2 21.9-9.9 1.3-.3 3.4-1.2 3.7 1.5.6 4.9 1.4 9.9 1.7 14.8.3 4.4.1 8.7.1 12.2 2.1 1.5 4.6 2.3 5.5 4 4.2 8.4 3.2 17.6 3.1 26.6 0 1.2-.4 3.3.1 3.6 10.3 4.9 20.7 9.6 31.1 14.4 2.5-4.9-2.3-16-15.8-14.4.6-.5 1.4-1.1 2.2-1.1 2.5.1 4.9.4 7.4.7 6 .8 10.9 3.7 14.6 8.4 1.2 1.5 1.6 4.2 1.1 6.1-.7 3.2-3.7 4-7.1 4.1 4.5 3.5 6.5 8.1 6.8 13.3.6 9.4-1.1 18.6-4.8 27.1-3.9 8.8-5.2 17.5-3.3 26.8.6 3.2 1.2 7 .2 9.9-2 6.2-7.8 8.6-13.4 10.9-3 1.2-7.4 1.2-6.3 6.3.8 3.7-.4 4 .2 4.5 5.8 5.8 11.8 11.5 17.6 17.3 1.7 1.7 3 3.8 4.3 5.5-1.1.4-1.8.7-2.4 1 7.5 5.8 14.9 11.6 22.4 17.4 4.3-4.3 8.6-9 13.3-13.2 8.1-7.3 16.7-14 24.5-21.7 3.3-3.3 4.9-8.2 7.4-12.3.3-.4 1.3-.9 1.6-.7 4.6 2.7 6.8 7.2 7.9 12.1 1.3 5.7 1.6 11.6 2.3 17.1 4.2-.2 8.8-.8 13.4-.4 2 .1 4.6 1.8 5.5 3.5 2.2 4.3 3.8 8.9 5.3 13.5 3.7 11.5 6.9 23.2 10.7 34.7 1.7 5.1 3.4 10.4 8.6 13.4.5.3.5 2.7 0 3.1-3.3 2.5-6.9 4.6-10.5 7 2 5.8 4.3 12.6 6.7 19.6.7-.8 1.4-1.6 2.1-2.3 1.9-1.9 3.5-1.6 4.2 1.2.7 3 1.3 6.2 1.5 9.3.3 7.3.4 14.6.6 21.9 0 .4.2.8.5 1.2 3.6 4.7 7.1 9.3 10.7 14 1.7 2.3 3 5.4 5.3 6.6 5.5 2.7 11.5 4.4 17.3 6.6v.7c-.4.3-.7.8-1.2 1-5.8 2.1-11.6 4.3-17.5 6.2-4.2 1.3-8.4 2-12.4-1.2-1.8-1.5-3.9-2.6-5.8-3.8 0 2.3.1 4.4-.1 6.4-.1.8-.7 2.2-1.2 2.2-2.6.2-5.3.1-7.9.1-1.1 0-2.7.3-3.2-.3-1-1.2-2.1-2.9-2.1-4.4-.1-5.2.1-10.4.3-15.6.1-1.8 1.5-3.9.9-5.4-1.7-4.3-4-8.4-6.1-12.5-2.4-4.6-6.4-9.1-1.2-14.3.3-.3.3-1.3 0-1.7-4.7-6.5-9.5-13.1-14.4-19.5-1.2-1.5-2.9-3.7-4.4-3.7-6.7.1-13.4.8-20.1 1.3-.7.1-1.6.2-1.9.6-7.1 9.1-14 18.3-21.1 27.4-1.3 1.7-2.9 3.4-4.3 5 1.7.6 3.3 1.1 4.8 1.7.6.2 1.3.5 1.6 1 .2.3-.1 1.1-.4 1.5-2 2.6-4.1 5.2-6.1 7.8-4.3 5.3-8.7 10.5-13 15.9-.8 1-1.5 2.4-1.6 3.6-.2 5.4-.1 10.7-.1 16.1 0 1.5-.7 3.6.1 4.5 2.4 3 5.3 5.5 7.9 8.2 1.6 1.7 3 3.5 4.6 5.5-2.6.2-4.5.3-6.4.4h-3.7c-4.8-1.4-9.8-2.5-14.5-4.3-3.5-1.4-7.8-2.5-8-7.7-.1-2.1-.2-4.3-.4-6.7-1 1.1-1.7 2.1-2.6 2.9-.3.3-1 .4-1.3.2-1.9-1.1-3.7-2.2-5.5-3.4-1.7-1.1-4.5-1.6-3.5-4.5 2.3-6.5 6.4-11.6 12.7-14.9.6-.3 1.3-.9 1.6-1.5 3.9-8.2 7.8-16.4 11.8-24.6.7-1.5.4-4.5 3.8-3.8.2.1 1.2-3.1 1.8-4.9-2.8 1.5-5 2.9-7.4 3.9-7.4 3-14.7 6.4-23.1 5.6-8.5-.7-16.2-3.4-23.2-8-9.9-6.7-14.2-17-17.5-27.9-.5-1.7-.5-5.1-3.5-1.6-.1.2-.4.2-.6.3-2.5 1.7-5.4 3-6 6.5-.4 2.3-1 4.6-1.5 7-2.9 13.2-4.2 26.4-2.5 39.9 1.7 13.1 9.2 21.3 21 26.3 2.4 1 4.9 1.9 7.5 2.9-2.1.9-3.9 1.9-5.8 2.3-10.2 2.5-20.5 4.9-30.8 7.1-1.9.4-4.9.7-5.9-.3-6.4-6.5-8.9-14.8-8.3-23.7.7-9.6 2.1-19.2 3.9-28.6 2.2-11.5 6.1-22.5 11.7-32.9.7-1.3 2-3.1 1.6-4.1-1.8-4.6-4.5-8.9-6.2-13.6-2-5.7-4.2-11.6-1.2-17.8.1-.1-.3-.5-.5-.8 7.6.7 12.8 5.3 17.7 10.2-1.3-8.5-2.6-17.2-3.9-25.8 0-.3-.2-.7-.4-.9-6.7-5.5-13.3-11.2-17-19.2-2.6-5.7-4.3-11.8-6.3-17.7-.6-1.6.2-3.4-2.2-4.8-5.9-3.5-10.3-8.6-10.3-16 0-1.8 1.2-5 2.2-5.1 8.3-1.2 16.4-.1 23.8 4.2 2.4 1.4 4.9 2.7 8.1 4.4-.4-8.8-.8-16.2-1.2-23.6-4.2.9-8.6.9-11.5-2-3.3-3.3-5.4-7.8-7.9-11.8-1.1-1.7-2-3.6-3.5-6.4-3.8 10.3-7.4 19.9-10.8 29.1-.3-.6-1.1-1.7-1.5-2.9-3.5-10-2.8-20.2-1.1-30.3 1.2-7.4 4.3-14.6 3.1-22.4-.2-1.1.2-2.3.3-3.4-22.1 17.6-38.8 38.4-42.9 67.4-4 28-2.8 54.8 13.5 79.1-36.3-13.8-53-48.6-58.3-84.1-3 8-15 16.3-22.4 16.6v-.2c2.1-2.9 11.1-10.6 7-30.2-1.3-10.7-4.1-21.2-5.1-31.9-1-10.9-1-21.9-.5-32.9.3-11.6 3.8-22.7 8.6-33.2 5.7-12.5 13.5-23.8 23-33.6 5.6-5.8 11.9-11 18.2-16.1 8.6-6.8 17.7-12.9 28.2-16.5 5.1-1.9 10.4-3 15.7-4.5zm96.4 221.9c-.4.9-1.2 2-1.1 3 .5 7.6 1.2 15.2 2 22.7.2 2.1 0 4.8 3.3 5.5 3.3.7 6.6 1.8 9.9 2.6.3.1.9-.1 1.1-.4 3.8-4.8 7.5-9.6 10.9-14-8.4-6.1-17.1-12.6-26.1-19.4zm-23.1-42.5v6.3c1.9-2 3.6-3.9 5.3-5.7-1.7-.2-3.5-.4-5.3-.6z\" />\n    </svg>\n  </div>\n</div> Notice that the background moves, Alice spins, and her color changes at an offset from her spinning. We're going to focus on just Alice for this tutorial. You can check the full source code by clicking \"Play\" on the code block. Here's the simplified CSS that controls Alice's animation: css #alice {\n  animation: alice-tumbling infinite 3s linear;\n}\n\n@keyframes alice-tumbling {\n  0% {\n    color: black;\n    transform: rotate(0) translate3d(-50%, -50%, 0);\n  }\n  30% {\n    color: #431236;\n  }\n  100% {\n    color: black;\n    transform: rotate(360deg) translate3d(-50%, -50%, 0);\n  }\n} #tunnel {\n  animation: tunnel-fly 1s linear infinite;\n}\n\n@keyframes tunnel-fly {\n  100% {\n    transform: translate3d(0, -300px, 0);\n  }\n} #alice {\n  color: #431236;\n  width: 25%;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform-origin: 0 0;\n  transform: rotate(0) translate3d(-50%, -50%, 0);\n  backface-visibility: hidden;\n  will-change: transform, color;\n}\n\npath {\n  fill: currentColor;\n}\n\n#tunnel {\n  background:\n    url(\"/shared-assets/images/examples/web-animations/bg-tunnel-border-left.svg\")\n      repeat-y,\n    url(\"/shared-assets/images/examples/web-animations/bg-tunnel-border-right.svg\")\n      repeat-y 100% 100%,\n    url(\"/shared-assets/images/examples/web-animations/bg-tunnel-specks.png\"),\n    #6c373f;\n  margin: 0 auto;\n  height: calc(100% + 300px);\n  width: 60%;\n  min-width: 400px;\n  backface-visibility: hidden;\n  will-change: transform;\n}\n\n.wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n\nbody {\n  background: black;\n}\n\nhtml,\nbody {\n  height: 100%;\n} This changes Alice's color and her transform's rotation over 3 seconds at a constant (linear) rate and loops infinitely. In the @keyframes block we can see that 30% of the way through each loop (about .9 seconds in), Alice's color changes from black to a deep burgundy then back again by the end of the loop. Moving it to JavaScript Now let's try creating the same animation with the Web Animations API. Representing keyframes The first thing we need is to create a Keyframe Object corresponding to our CSS @keyframes block: js const aliceTumbling = [\n  { transform: \"rotate(0) translate3d(-50%, -50%, 0)\", color: \"black\" },\n  { color: \"#431236\", offset: 0.3 },\n  { transform: \"rotate(360deg) translate3d(-50%, -50%, 0)\", color: \"black\" },\n]; Here we're using an array containing multiple objects. Each object represents a key from the original CSS. However, unlike CSS, the Web Animations API doesn't need to explicitly be told the percentages along the animation for each key to appear at. It will automatically divide the animation into equal parts based on the number of keys you give it. This means that a Keyframe object with three keys will play the middle key 50% of the way through each loop of the animation unless told otherwise. When we want to explicitly set a key's offset from the other keys, we can specify an offset directly in the object, separated from the declaration with a comma. In the above example, to make sure that Alice's color changes at 30% (not 50%) for the color change, we are giving it offset: 0.3 . Currently, there should be at least two keyframes specified (representing the starting and ending states of the animation sequence). If your keyframe list has only one entry, Element.animate() may throw a NotSupportedError DOMException in some browsers until they are updated. So to recap, the keys are equally spaced by default unless you specify an offset on a key. Handy, no? Representing timing properties We'll also need to create an object of timing properties corresponding to the values in Alice's animation: js const aliceTiming = {\n  duration: 3000,\n  iterations: Infinity,\n}; You'll notice a few differences here from how equivalent values are represented in CSS: For one, the duration is in milliseconds as opposed to seconds \u2014 3000 not 3s. Like setTimeout() and Window.requestAnimationFrame() , the Web Animations API only takes milliseconds. The other thing you'll notice is that it's iterations , not iteration-count . Note: There are a number of small differences between the terminology used in CSS Animations and the terminology used in Web Animations. For instance, Web Animations doesn't use the string \"infinite\" , but instead uses the JavaScript keyword Infinity . And instead of timing-function we use easing . We aren't listing an easing value here because, unlike CSS Animations where the default animation-timing-function is ease , in the Web Animations API the default easing is linear \u2014 which is what we want here. Bring the pieces together Now it's time to bring them both together with the Element.animate() method: js document.getElementById(\"alice\").animate(aliceTumbling, aliceTiming); And boom: the animation starts playing: document\n  .getElementById(\"tunnel\")\n  .animate(\n    [\n      { transform: \"translate3d(0, 0, 0)\" },\n      { transform: \"translate3d(0, -300px, 0)\" },\n    ],\n    {\n      duration: 1000,\n      iterations: Infinity,\n    },\n  ); The animate() method can be called on any DOM element that could be animated with CSS. And it can be written in several ways. Instead of making objects for keyframes and timing properties, we could just pass their values in directly, like so: js document.getElementById(\"alice\").animate(\n  [\n    { transform: \"rotate(0) translate3d(-50%, -50%, 0)\", color: \"black\" },\n    { color: \"#431236\", offset: 0.3 },\n    { transform: \"rotate(360deg) translate3d(-50%, -50%, 0)\", color: \"black\" },\n  ],\n  {\n    duration: 3000,\n    iterations: Infinity,\n  },\n); What's more, if we only wanted to specify the duration of the animation and not its iterations (by default, animations iterate once), we could pass in the milliseconds alone: js document.getElementById(\"alice\").animate(\n  [\n    { transform: \"rotate(0) translate3d(-50%, -50%, 0)\", color: \"black\" },\n    { color: \"#431236\", offset: 0.3 },\n    { transform: \"rotate(360deg) translate3d(-50%, -50%, 0)\", color: \"black\" },\n  ],\n  3000,\n); Controlling playback with play(), pause(), reverse(), and updatePlaybackRate() While we can write CSS Animations with the Web Animations API, where the API really comes in handy is manipulating the animation's playback. The Web Animations API provides several useful methods for controlling playback. Let's take a look at pausing and playing animations in the Follow the White Rabbit example: In this example, the white rabbit has an animation that causes it to go down a rabbit hole. It's only triggered when the user clicks on it. <div class=\"wrapper\">\n  <div class=\"page\">\n    <div class=\"background\"></div>\n    <div id=\"rabbit\">Click the rabbit's ears!</div>\n    <div class=\"foreground\"></div>\n    <p>\n      She was just in time to see him pop down a hole between a great tree's\n      roots.\n    </p>\n  </div>\n</div> #rabbit {\n  background: url(\"/shared-assets/images/examples/web-animations/park5_rabbit.png\")\n    0 0 / 100% 100%;\n  cursor: pointer;\n  position: absolute;\n  top: 15%;\n  left: 60%;\n  width: 14.64844%;\n  padding-top: 31.00586%;\n}\n\nbody {\n  background: black;\n}\n.wrapper {\n  max-width: 133.33vh;\n  margin: 0 auto;\n}\n.page {\n  background: #431236;\n  height: 0;\n  overflow: hidden;\n  padding-top: 75%;\n  position: relative;\n  text-indent: 100%;\n  white-space: nowrap;\n}\n\n.foreground {\n  height: 100%;\n  background: url(\"/shared-assets/images/examples/web-animations/bg_park5_2.png\")\n    no-repeat 100% 100% / 100% auto;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  width: 100%;\n  pointer-events: none;\n}\n\n.background {\n  background: url(\"/shared-assets/images/examples/web-animations/bg_park5_1.png\")\n    no-repeat 0 0 / 100% auto;\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n} Pausing and playing animations We can animate the rabbit using the animate() method as usual: js const whiteRabbit = document.getElementById(\"rabbit\");\n\nconst rabbitDownAnimation = whiteRabbit.animate(\n  [{ transform: \"translateY(0%)\" }, { transform: \"translateY(100%)\" }],\n  { duration: 3000, fill: \"forwards\" },\n); The Element.animate() method will immediately run after it is called. To prevent the cake from eating itself up before the user has had the chance to click on it, we call Animation.pause() on it immediately after it is defined, like so: js rabbitDownAnimation.pause(); Note: Alternatively, you can define rabbitDownAnimation using the Animation() constructor instead, which doesn't start playing until you call play() . We can now use the Animation.play() method to run it whenever we're ready. Specifically, we want to link it to a clicking action. We can achieve this via the following: js whiteRabbit.addEventListener(\"click\", downHeGoes);\nwhiteRabbit.addEventListener(\"touchstart\", downHeGoes);\n\nfunction downHeGoes(event) {\n  whiteRabbit.removeEventListener(\"click\", downHeGoes);\n  whiteRabbit.removeEventListener(\"touchstart\", downHeGoes);\n\n  rabbitDownAnimation.play();\n} When a user clicks or presses their finger on the rabbit, we can now call downHeGoes to make all the animations play. Other useful methods In addition to pausing and playing, we can use the following Animation methods: Animation.finish() skips to the end of the animation. Animation.cancel() aborts the animation and removes its effects. Animation.reverse() sets the animation's playback rate ( Animation.playbackRate ) to a negative value so it runs backward. Let's take a look at playbackRate first \u2014 a negative playbackRate will cause an animation to run in reverse.\nIn Through the Looking-Glass , Alice travels to a world where she must run to stay in place \u2014 and run twice as fast to move forward! In the Red Queen's Race example, Alice and the Red Queen are running to stay in place: <div class=\"wrapper\">\n  <div class=\"sky\"></div>\n  <div class=\"earth\">\n    <div id=\"red-queen-and-alice\">\n      <img\n        id=\"red-queen-and-alice-sprite\"\n        src=\"/shared-assets/images/examples/web-animations/sprite_running-alice-queen_small.png\"\n        srcset=\"\n          /shared-assets/images/examples/web-animations/sprite_running-alice-queen.png 2x\n        \"\n        alt=\"Alice and the Red Queen running to stay in place.\" />\n    </div>\n  </div>\n  <div class=\"scenery\" id=\"foreground1\">\n    <img\n      id=\"palm3\"\n      src=\"/shared-assets/images/examples/web-animations/palm3_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/palm3.png 2x\"\n      alt=\"\" />\n  </div>\n  <div class=\"scenery\" id=\"foreground2\">\n    <img\n      id=\"bush\"\n      src=\"/shared-assets/images/examples/web-animations/bush_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/bush.png 2x\"\n      alt=\"\" />\n    <img\n      id=\"w_rook_upright\"\n      src=\"/shared-assets/images/examples/web-animations/w_rook_upright_small.png\"\n      srcset=\"\n        /shared-assets/images/examples/web-animations/w_rook_upright.png 2x\n      \"\n      alt=\"\" />\n  </div>\n  <div class=\"scenery\" id=\"background1\">\n    <img\n      id=\"r_pawn_upright\"\n      src=\"/shared-assets/images/examples/web-animations/r_pawn_upright_small.png\"\n      srcset=\"\n        /shared-assets/images/examples/web-animations/r_pawn_upright.png 2x\n      \"\n      alt=\"\" />\n    <img\n      id=\"w_rook\"\n      src=\"/shared-assets/images/examples/web-animations/w_rook_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/w_rook.png 2x\"\n      alt=\"\" />\n    <img\n      id=\"palm1\"\n      src=\"/shared-assets/images/examples/web-animations/palm1_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/palm1.png 2x\"\n      alt=\"\" />\n  </div>\n  <div class=\"scenery\" id=\"background2\">\n    <img\n      id=\"r_pawn\"\n      src=\"/shared-assets/images/examples/web-animations/r_pawn_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/r_pawn.png 2x\"\n      alt=\"\" />\n\n    <img\n      id=\"r_knight\"\n      src=\"/shared-assets/images/examples/web-animations/r_knight_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/r_knight.png 2x\"\n      alt=\"\" />\n    <img\n      id=\"palm2\"\n      src=\"/shared-assets/images/examples/web-animations/palm2_small.png\"\n      srcset=\"/shared-assets/images/examples/web-animations/palm2.png 2x\"\n      alt=\"\" />\n  </div>\n</div> * {\n  user-select: none;\n}\n\nimg {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.scenery {\n  width: 100%;\n  height: 50%;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n}\n\n#foreground1,\n#foreground2 {\n  z-index: 1;\n}\n\n#foreground2,\n#background2 {\n  transform: translateX(100%);\n}\n\n#palm3 {\n  top: 0;\n  left: 10%;\n}\n\n#w_rook_upright {\n  top: 30%;\n  left: 75%;\n}\n\n#r_pawn {\n  top: 10%;\n  left: 15%;\n}\n\n#w_rook {\n  top: 10%;\n  left: 80%;\n}\n\n#r_pawn_upright {\n  top: 5%;\n  left: 30%;\n}\n\n#r_knight {\n  top: 0;\n  left: 70%;\n}\n\n#palm2 {\n  top: -15%;\n  left: 90%;\n}\n\n#palm1 {\n  top: -15%;\n  left: 40%;\n}\n\n#bush {\n  top: 55%;\n  left: 20%;\n}\n\n#red-queen-and-alice {\n  position: absolute;\n  top: 0;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  overflow: hidden;\n  width: 80%;\n  max-width: 450px;\n  z-index: 1;\n}\n\n#red-queen-and-alice::before {\n  content: \" \";\n  display: block;\n  padding-top: 87%;\n}\n\n#red-queen-and-alice img {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n}\n\n.sky,\n.earth {\n  position: absolute;\n  left: 0;\n  height: 50vh;\n  width: 100%;\n}\n\n.earth {\n  background: #eb125d\n    url(\"/shared-assets/images/examples/web-animations/bg_earth.jpg\") repeat-x 0\n    0 / 100% auto;\n  bottom: 0;\n}\n\n.sky {\n  background: #246e89\n    url(\"/shared-assets/images/examples/web-animations/bg_sky.jpg\") repeat-x\n    100% 100% / auto 100%;\n  top: 0;\n}\n\nhtml,\nbody {\n  width: 100%;\n  height: 100%;\n}\n\n.wrapper {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n} const background1 = document.getElementById(\"background1\");\nconst background2 = document.getElementById(\"background2\");\n\nconst foreground1 = document.getElementById(\"foreground1\");\nconst foreground2 = document.getElementById(\"foreground2\");\n\nconst redQueenAliceSprite = document.getElementById(\n  \"red-queen-and-alice-sprite\",\n);\n\n/* Background animations */\nconst sceneryFrames = [\n  { transform: \"translateX(100%)\" },\n  { transform: \"translateX(-100%)\" },\n];\n\nconst sceneryTimingBackground = {\n  duration: 36000,\n  iterations: Infinity,\n};\n\nconst sceneryTimingForeground = {\n  duration: 12000,\n  iterations: Infinity,\n};\n\nconst background1Movement = background1.animate(\n  sceneryFrames,\n  sceneryTimingBackground,\n);\nbackground1Movement.currentTime =\n  background1Movement.effect.getComputedTiming().duration / 2;\n\nconst background2Movement = background2.animate(\n  sceneryFrames,\n  sceneryTimingBackground,\n);\n\nconst foreground1Movement = foreground1.animate(\n  sceneryFrames,\n  sceneryTimingForeground,\n);\nforeground1Movement.currentTime =\n  foreground1Movement.effect.getComputedTiming().duration / 2;\n\nconst foreground2Movement = foreground2.animate(\n  sceneryFrames,\n  sceneryTimingForeground,\n);\n\nconst spriteFrames = [\n  { transform: \"translateY(0)\" },\n  { transform: \"translateY(-100%)\" },\n];\n\nconst redQueenAlice = redQueenAliceSprite.animate(spriteFrames, {\n  easing: \"steps(7, end)\",\n  direction: \"reverse\",\n  duration: 600,\n  playbackRate: 1,\n  iterations: Infinity,\n}); Because small children tire out easily, unlike automaton chess pieces, Alice is constantly slowing down. We can do this by setting a decay on her animation's playbackRate . We use updatePlaybackRate() instead of setting the playbackRate directly since that produces a smooth update: js setInterval(() => {\n  // Make sure the playback rate never falls below .4\n  if (redQueenAlice.playbackRate > 0.4) {\n    redQueenAlice.updatePlaybackRate(redQueenAlice.playbackRate * 0.9);\n  }\n  adjustBackgroundPlayback();\n}, 1000); But urging them on by clicking or tapping causes them to speed up by multiplying their playbackRate : js function goFaster() {\n  // But you can speed them up by giving the screen a click or a tap.\n  redQueenAlice.updatePlaybackRate(redQueenAlice.playbackRate * 1.1);\n  adjustBackgroundPlayback();\n}\n\ndocument.addEventListener(\"click\", goFaster);\ndocument.addEventListener(\"touchstart\", goFaster); The background elements also have playbackRate s that are impacted when you click or tap. Their playback rates are derived from Alice's, shown below. What happens when you make Alice and the Red Queen run twice as fast? What happens when you let them slow down? js /* Alice tires so easily! \n  Every so many seconds, reduce their playback rate so they slow a little. \n*/\nconst sceneries = [\n  foreground1Movement,\n  foreground2Movement,\n  background1Movement,\n  background2Movement,\n];\n\nfunction adjustBackgroundPlayback() {\n  // If Alice and the Red Queen are running at a speed of 0.8\u20131.2,\n  // the background doesn't move.\n  // But if they fall under 0.8, the background slides backwards\n  if (redQueenAlice.playbackRate < 0.8) {\n    sceneries.forEach((anim) => {\n      anim.updatePlaybackRate(-redQueenAlice.playbackRate / 2);\n    });\n  } else if (redQueenAlice.playbackRate > 1.2) {\n    sceneries.forEach((anim) => {\n      anim.updatePlaybackRate(redQueenAlice.playbackRate / 2);\n    });\n  } else {\n    sceneries.forEach((anim) => {\n      anim.updatePlaybackRate(0);\n    });\n  }\n}\nadjustBackgroundPlayback(); Persisting animation styles When animating elements, a common use case is to persist the final state of the animation, after the animation has finished. One method sometimes used for this is to set the animation's fill mode to forwards . However, it is not recommended to use fill modes to persist the effect of an animation indefinitely, for two reasons: The browser has to maintain the state of the animation while it is still active, so the animation continues to consume resources even though it is no longer animating. Note that this is somewhat alleviated by the browser automatically removing filling animations . Styles applied by animations have a higher precedence in the cascade than specified styles, so it can be difficult to override them when needed. A better approach is to use the Animation.commitStyles() method. This writes the computed values of the animation's current styles into its target element's style attribute, after which the element can be restyled normally. Automatically removing filling animations It is possible to trigger a large number of animations on the same element. If they are indefinite (i.e., forwards-filling), this can result in a huge animations list, which could create a memory leak. For this reason, browsers automatically remove filling animations after they are replaced by newer animations, unless the developer explicitly specifies to keep them. Animations are removed when all of the following are true: The animation is filling (its fill is forwards if it is playing forwards, backwards if it is playing backwards, or both ). The animation is finished. (Note that because of the fill it will still be in effect.) The animation's timeline is monotonically increasing. (This is always true for DocumentTimeline ; other timelines such as scroll-timeline can run backwards.) The animation is not being controlled by declarative markup such as CSS. Every styling effect of the animation's AnimationEffect is being overridden by another animation that also satisfies all the conditions above. (Typically, when two animations would set the same style property of the same element, the one created last overrides the other.) The first four conditions ensure that, without intervention by JavaScript code, the animation's effect will never change or end. The last condition ensures that the animation will never actually affect the style of any element: it has been entirely replaced. When the animation is automatically removed, the animation's remove event fires. To prevent the browser from automatically removing animations, call the animation's persist() method. The animation's replaceState property will be removed if the animation has been removed, persisted if you have called persist() on the animation, or active otherwise. Getting information out of animations Imagine other ways we could use playbackRate, such as improving accessibility for users with vestibular disorders by letting them slow down animations across an entire site. That's impossible to do with CSS without recalculating durations in every CSS rule, but with the Web Animations API, we could use the Document.getAnimations method to loop over each animation on the page and halve their playbackRate s, like so: js document.getAnimations().forEach((animation) => {\n  animation.updatePlaybackRate(animation.playbackRate * 0.5);\n}); With the Web Animations API, all you need to change is just one little property! Another thing that's tough to do with CSS Animations alone is creating dependencies on values provided by other animations. For instance, in the Growing and Shrinking Alice game example, you might have noticed something odd about the cake's duration: js document.getElementById(\"eat-me-sprite\").animate([], {\n  duration: aliceChange.effect.getComputedTiming().duration / 2,\n}); To understand what's happening here, let's take a look at Alice's animation: js const aliceChange = document\n  .getElementById(\"alice\")\n  .animate(\n    [\n      { transform: \"translate(-50%, -50%) scale(.5)\" },\n      { transform: \"translate(-50%, -50%) scale(2)\" },\n    ],\n    {\n      duration: 8000,\n      easing: \"ease-in-out\",\n      fill: \"both\",\n    },\n  ); Alice's animation has her going from half her size to twice her size over 8 seconds. Then we pause her: js aliceChange.pause(); If we had left her paused at the beginning of her animation, she'd start at half her full size, as if she'd drunk the entire bottle already! We want to set her animation's \"playhead\" in the middle, so she's already halfway done. We could do that by setting her Animation.currentTime to 4 seconds, like so: js aliceChange.currentTime = 4000; But while working on this animation, we might change Alice's duration a lot. Wouldn't it be better if we set her currentTime dynamically, so we don't have to make two updates at a time? We can, in fact, do so by referencing aliceChange's Animation.effect property, which returns an object containing all the details of the effect(s) active on Alice: js aliceChange.currentTime = aliceChange.effect.getComputedTiming().duration / 2; effect lets us access the animation's keyframes and timing properties \u2014 aliceChange.effect.getComputedTiming() points to Alice's timing object \u2014 this contains her duration . We can divide her duration in half to get the midpoint for her animation's timeline, setting her to be normal height. Now we can reverse and play her animation in either direction to make her grow smaller or larger! And we can do the same thing when setting the cake and bottle durations: js const drinking = document\n  .getElementById(\"liquid\")\n  .animate([{ height: \"100%\" }, { height: \"0\" }], {\n    fill: \"forwards\",\n    duration: aliceChange.effect.getComputedTiming().duration / 2,\n  });\ndrinking.pause(); Now all three animations are linked to just one duration, which we can change easily from one place. We can also use the Web Animations API to figure out the animation's current time. The game ends when you run out of cake to eat or empty the bottle. Which vignette players are presented with depends on how far along Alice was in her animation, whether she grew too big and can't get in the tiny door anymore or too small and cannot reach the key to open the door. We can figure out whether she's on the large end or small end of her animation by getting her animation's currentTime and dividing it by her activeDuration : js const endGame = () => {\n  // get Alice's timeline's playhead location\n  const alicePlayhead = aliceChange.currentTime;\n  const aliceTimeline = aliceChange.effect.getComputedTiming().activeDuration;\n\n  // stops Alice's and other animations\n  stopPlayingAlice();\n\n  // depending on which third it falls into\n  const aliceHeight = alicePlayhead / aliceTimeline;\n\n  if (aliceHeight <= 0.333) {\n    // Alice got smaller!\n    // \u2026\n  } else if (aliceHeight >= 0.666) {\n    // Alice got bigger!\n    // \u2026\n  } else {\n    // Alice didn't change significantly\n    // \u2026\n  }\n}; Callbacks and promises CSS Animations and Transitions have their own event listeners, and these are also possible with the Web Animations API: onfinish is the event handler for the finish event and can be triggered manually with finish() . oncancel is the event handler for the cancel event and can be triggers with cancel() . Here we set the callbacks for the cake, bottle, and Alice to fire the endGame function: js // When the cake or bottle runs out\nnommingCake.onfinish = endGame;\ndrinking.onfinish = endGame;\n\n// Alice reaches the end of her animation\naliceChange.onfinish = endGame; Better still, the Web Animations API also provides a finished promise that will resolve when the animation finishes, or reject if it is canceled. Conclusion These are the basic features of the Web Animations API. By now you should be ready to \"jump down the rabbit hole\" of animating in the browser and ready to write your own animation experiments! See also The full suite of Alice in Wonderland demos on CodePen for you to play with, fork, and share. Animating like you just don't care with Element.animate (2016) Explains the background of the Web Animations API and why it is more performant than other web animation methods. Help improve MDN Learn how to contribute This page was last modified on \u2068Nov 7, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content"
    }
  },
  "metadata": {
    "jsonld": [],
    "microdata": [],
    "opengraph": {},
    "twitter": {
      "card": "summary_large_image",
      "creator": "MozDevNet"
    }
  },
  "timestamp": "2025-12-04T13:38:17.474906"
}