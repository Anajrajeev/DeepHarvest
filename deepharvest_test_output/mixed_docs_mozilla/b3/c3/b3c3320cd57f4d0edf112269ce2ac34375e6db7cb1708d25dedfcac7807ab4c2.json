{
  "url": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",
  "content": {
    "text": {
      "title": "Using Web Workers - Web APIs | MDN",
      "text": "Using Web Workers - Web APIs | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all\u2026 HTML guides Responsive images HTML cheatsheet Date & time formats See all\u2026 Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values See all\u2026 CSS guides Box model Animations Flexbox Colors See all\u2026 Layout cookbook Column layouts Centering an element Card component See all\u2026 JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all\u2026 JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all\u2026 Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all\u2026 Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all\u2026 Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started modules Core modules MDN Curriculum Learn HTML Structuring content with HTML module Learn CSS CSS styling basics module CSS layout module Learn JavaScript Dynamic scripting with JavaScript module Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Web Web APIs Web Workers API Using Web Workers Using Web Workers Web Workers are a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. In addition, they can make network requests using the fetch() or XMLHttpRequest APIs. Once created, a worker can send messages to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa). This article provides a detailed introduction to using web workers. In this article Web Workers API Dedicated workers Shared workers About thread safety Content security policy Transferring data to and from workers: further details Embedded workers Further examples Other types of workers Debugging worker threads Functions and interfaces available in workers Specifications See also Web Workers API A worker is an object created using a constructor (e.g., Worker() ) that runs a named JavaScript file \u2014 this file contains the code that will run in the worker thread; workers run in another global context that is different from the current window . Thus, using the window shortcut to get the current global scope (instead of self ) within a Worker will return an error. The worker context is represented by a DedicatedWorkerGlobalScope object in the case of dedicated workers (standard workers that are utilized by a single script; shared workers use SharedWorkerGlobalScope ). A dedicated worker is only accessible from the script that first spawned it, whereas shared workers can be accessed from multiple scripts. Note: See The Web Workers API landing page for reference documentation on workers and additional guides. You can run whatever code you like inside the worker thread, with some exceptions. For example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the window object. But you can use a large number of items available under window , including WebSockets , and data storage mechanisms like IndexedDB . See Functions and classes available to workers for more details. Data is sent between workers and the main thread via a system of messages \u2014 both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data attribute). The data is copied rather than shared. Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page. In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null ). Dedicated workers As mentioned above, a dedicated worker is only accessible by the script that called it. In this section we'll discuss the JavaScript found in our Basic dedicated worker example ( run dedicated worker ): This allows you to enter two numbers to be multiplied together. The numbers are sent to a dedicated worker, multiplied together, and the result is returned to the page and displayed. This example is rather trivial, but we decided to keep it simple while introducing you to basic worker concepts. More advanced details are covered later on in the article. Worker feature detection For slightly more controlled error handling and backwards compatibility, it is a good idea to wrap your worker accessing code in the following ( main.js ): js if (window.Worker) {\n  // \u2026\n} Spawning a dedicated worker Creating a new worker is simple. All you need to do is call the Worker() constructor, specifying the URI of a script to execute in the worker thread ( main.js ): js const myWorker = new Worker(\"worker.js\"); Note: Bundlers, including webpack , Vite , and Parcel , recommend passing URLs that are resolved relative to import.meta.url to the Worker() constructor. For example: js const myWorker = new Worker(new URL(\"worker.js\", import.meta.url)); This way, the path is relative to the current script instead of the current HTML page, which allows the bundler to safely do optimizations like renaming (because otherwise the worker.js URL may point to a file not controlled by the bundler, so it cannot make any assumptions). Sending messages to and from a dedicated worker The magic of workers happens via the postMessage() method and the onmessage event handler. When you want to send a message to the worker, you post messages to it like this ( main.js ): js [first, second].forEach((input) => {\n  input.onchange = () => {\n    myWorker.postMessage([first.value, second.value]);\n    console.log(\"Message posted to worker\");\n  };\n}); So here we have two <input> elements represented by the variables first and second ; when the value of either is changed, myWorker.postMessage([first.value,second.value]) is used to send the value inside both to the worker, as an array. You can send pretty much anything you like in the message. In the worker, we can respond when the message is received by writing an event handler block like this ( worker.js ): js onmessage = (e) => {\n  console.log(\"Message received from main script\");\n  const workerResult = `Result: ${e.data[0] * e.data[1]}`;\n  console.log(\"Posting message back to main script\");\n  postMessage(workerResult);\n}; The onmessage handler allows us to run some code whenever a message is received, with the message itself being available in the message event's data attribute. Here we multiply together the two numbers then use postMessage() again, to post the result back to the main thread. Back in the main thread, we use onmessage again, to respond to the message sent back from the worker: js myWorker.onmessage = (e) => {\n  result.textContent = e.data;\n  console.log(\"Message received from worker\");\n}; Here we grab the message event data and set it as the textContent of the result paragraph, so the user can see the result of the calculation. Note: Notice that onmessage and postMessage() need to be hung off the Worker object when used in the main script thread, but not when used in the worker. This is because, inside the worker, the worker is effectively the global scope. Note: When a message is passed between the main thread and worker, it is copied or \"transferred\" (moved), not shared. Read Transferring data to and from workers: further details for a much more thorough explanation. Terminating a worker If you need to immediately terminate a running worker from the main thread, you can do so by calling the worker's terminate method: js myWorker.terminate(); The worker thread is killed immediately. Handling errors When a runtime error occurs in the worker, its onerror event handler is called. It receives an event named error which implements the ErrorEvent interface. The event doesn't bubble and is cancelable; to prevent the default action from taking place, the worker can call the error event's preventDefault() method. The error event has the following three fields that are of interest: message A human-readable error message. filename The name of the script file in which the error occurred. lineno The line number of the script file on which the error occurred. Spawning subworkers Workers may spawn more workers if they wish. So-called sub-workers must be hosted within the same origin as the parent page. Also, the URIs for subworkers are resolved relative to the parent worker's location rather than that of the owning page. This makes it easier for workers to keep track of where their dependencies are. Importing scripts and libraries Worker threads have access to a global function, importScripts() , which lets them import scripts. It accepts zero or more URIs as parameters to resources to import; all the following examples are valid: js importScripts(); /* imports nothing */\nimportScripts(\"foo.js\"); /* imports just \"foo.js\" */\nimportScripts(\"foo.js\", \"bar.js\"); /* imports two scripts */\nimportScripts(\n  \"//example.com/hello.js\",\n); /* You can import scripts from other origins */ The browser loads each listed script and executes it. Any global objects from each script may then be used by the worker. If the script can't be loaded, NETWORK_ERROR is thrown, and subsequent code will not be executed. Previously executed code (including code deferred using setTimeout() ) will still be functional though. Function declarations after the importScripts() method are also kept, since these are always evaluated before the rest of the code. Note: Scripts may be downloaded in any order, but will be executed in the order in which you pass the filenames into importScripts() . This is done synchronously; importScripts() does not return until all the scripts have been loaded and executed. Shared workers A shared worker is accessible by multiple scripts \u2014 even if they are being accessed by different windows, iframes or even workers. In this section we'll discuss the JavaScript found in our Basic shared worker example ( run shared worker ): This is very similar to the basic dedicated worker example, except that it has two functions available handled by different script files: multiplying two numbers , or squaring a number . Both scripts use the same worker to do the actual calculation required. Here we'll concentrate on the differences between dedicated and shared workers. Note that in this example we have two HTML pages, each with JavaScript applied that uses the same single worker file. Note: If SharedWorker can be accessed from several browsing contexts, all those browsing contexts must share the exact same origin (same protocol, host, and port). Note: In Firefox, shared workers cannot be shared between documents loaded in private and non-private windows ( Firefox bug 1177621 ). Spawning a shared worker Spawning a new shared worker is pretty much the same as with a dedicated worker, but with a different constructor name (see index.html and index2.html ) \u2014 each one has to spin up the worker using code like the following: js const myWorker = new SharedWorker(\"worker.js\"); One big difference is that with a shared worker you have to communicate via a port object \u2014 an explicit port is opened that the scripts can use to communicate with the worker (this is done implicitly in the case of dedicated workers). The port connection needs to be started either implicitly by use of the onmessage event handler or explicitly with the start() method before any messages can be posted. Calling start() is only needed if the message event is wired up via the addEventListener() method. Note: When using the start() method to open the port connection, it needs to be called from both the parent thread and the worker thread if two-way communication is needed. Sending messages to and from a shared worker Now messages can be sent to the worker as before, but the postMessage() method has to be invoked through the port object (again, you'll see similar constructs in both multiply.js and square.js ): js squareNumber.onchange = () => {\n  myWorker.port.postMessage([squareNumber.value, squareNumber.value]);\n  console.log(\"Message posted to worker\");\n}; Now, on to the worker. There is a bit more complexity here as well ( worker.js ): js onconnect = (e) => {\n  const port = e.ports[0];\n\n  port.onmessage = (e) => {\n    const workerResult = `Result: ${e.data[0] * e.data[1]}`;\n    port.postMessage(workerResult);\n  };\n}; First, we use an onconnect handler to fire code when a connection to the port happens (i.e., when the onmessage event handler in the parent thread is set up, or when the start() method is explicitly called in the parent thread). We use the ports attribute of this event object to grab the port and store it in a variable. Next, we add an onmessage handler on the port to do the calculation and return the result to the main thread. Setting up this onmessage handler in the worker thread also implicitly opens the port connection back to the parent thread, so the call to port.start() is not actually needed, as noted above. Finally, back in the main script, we deal with the message (again, you'll see similar constructs in both multiply.js and square.js ): js myWorker.port.onmessage = (e) => {\n  result2.textContent = e.data;\n  console.log(\"Message received from worker\");\n}; When a message comes back through the port from the worker, we insert the calculation result inside the appropriate result paragraph. About thread safety The Worker interface spawns real OS-level threads, and mindful programmers may be concerned that concurrency can cause \"interesting\" effects in your code if you aren't careful. However, since web workers have carefully controlled communication points with other threads, it's actually very hard to cause concurrency problems. There's no access to non-thread-safe components or the DOM. And you have to pass specific data in and out of a thread through serialized objects. So you have to work really hard to cause problems in your code. Content security policy Workers are considered to have their own execution context, distinct from the document that created them. For this reason they are, in general, not governed by the content security policy of the document (or parent worker) that created them. So for example, suppose a document is served with the following header: http Content-Security-Policy: script-src 'self' Among other things, this will prevent any scripts it includes from using eval() . However, if the script constructs a worker, code running in the worker's context will be allowed to use eval() . To specify a content security policy for the worker, set a Content-Security-Policy response header for the request which delivered the worker script itself. The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the CSP of the document or worker that created it. Transferring data to and from workers: further details Data passed between the main page and workers is copied , not shared (except for certain objects that can be explicitly shared ). Objects are serialized as they're handed to the worker, and subsequently, de-serialized on the other end. The page and worker do not share the same instance , so the end result is that a duplicate is created on each end. Most browsers implement this feature as structured cloning . As you probably know by now, data is exchanged between the two threads via messages using postMessage() , and the message event's data attribute contains data passed back from the worker. example.html : (the main page): js const myWorker = new Worker(\"my_task.js\");\n\nmyWorker.onmessage = (event) => {\n  console.log(`Worker said : \"${event.data}\"`);\n};\n\nmyWorker.postMessage({ lastUpdate: new Date() }); my_task.js (the worker): js self.onmessage = (event) => {\n  postMessage(`Last updated: ${event.data.lastUpdate.toDateString()}`);\n}; The structured cloning algorithm can accept JSON and a few things that JSON can't \u2014 like circular references. Passing data examples Example 1: Advanced passing JSON Data and creating a switching system If you have to pass some complex data and have to call many different functions both on the main page and in the Worker, you can create a system which groups everything together. First, we create a QueryableWorker class that takes the URL of the worker, a default listener, and an error handler, and this class is going to keep track of a list of listeners and help us communicate with the worker: js function QueryableWorker(url, defaultListener, onError) {\n  const worker = new Worker(url);\n  const listeners = {};\n\n  this.defaultListener = defaultListener ?? (() => {});\n\n  if (onError) {\n    worker.onerror = onError;\n  }\n\n  this.postMessage = (message) => {\n    worker.postMessage(message);\n  };\n\n  this.terminate = () => {\n    worker.terminate();\n  };\n} Then we add the methods of adding/removing listeners: js this.addListeners = (name, listener) => {\n  listeners[name] = listener;\n};\n\nthis.removeListeners = (name) => {\n  delete listeners[name];\n}; Here we let the worker handle two simple operations for illustration: getting the difference of two numbers and making an alert after three seconds. In order to achieve that we first implement a sendQuery method which queries if the worker actually has the corresponding methods to do what we want. js // This functions takes at least one argument, the method name we want to query.\n// Then we can pass in the arguments that the method needs.\nthis.sendQuery = (queryMethod, ...queryMethodArguments) => {\n  if (!queryMethod) {\n    throw new TypeError(\n      \"QueryableWorker.sendQuery takes at least one argument\",\n    );\n  }\n  worker.postMessage({\n    queryMethod,\n    queryMethodArguments,\n  });\n}; We finish QueryableWorker with the onmessage method. If the worker has the corresponding methods we queried, it should return the name of the corresponding listener and the arguments it needs, we just need to find it in listeners .: js worker.onmessage = (event) => {\n  if (\n    event.data instanceof Object &&\n    Object.hasOwn(event.data, \"queryMethodListener\") &&\n    Object.hasOwn(event.data, \"queryMethodArguments\")\n  ) {\n    listeners[event.data.queryMethodListener].apply(\n      this,\n      event.data.queryMethodArguments,\n    );\n  } else {\n    this.defaultListener(event.data);\n  }\n}; Now onto the worker. First we need to have the methods to handle the two simple operations: js const queryableFunctions = {\n  getDifference(a, b) {\n    reply(\"printStuff\", a - b);\n  },\n  waitSomeTime() {\n    setTimeout(() => {\n      reply(\"doAlert\", 3, \"seconds\");\n    }, 3000);\n  },\n};\n\nfunction reply(queryMethodListener, ...queryMethodArguments) {\n  if (!queryMethodListener) {\n    throw new TypeError(\"reply - takes at least one argument\");\n  }\n  postMessage({\n    queryMethodListener,\n    queryMethodArguments,\n  });\n}\n\n// This method is called when main page calls QueryWorker's postMessage\n// method directly\nfunction defaultReply(message) {\n  // do something\n} And the onmessage method is now trivial: js onmessage = (event) => {\n  if (\n    event.data instanceof Object &&\n    Object.hasOwn(event.data, \"queryMethod\") &&\n    Object.hasOwn(event.data, \"queryMethodArguments\")\n  ) {\n    queryableFunctions[event.data.queryMethod].apply(\n      self,\n      event.data.queryMethodArguments,\n    );\n  } else {\n    defaultReply(event.data);\n  }\n}; Here are the full implementation: example.html (the main page): html <ul>\n  <li>\n    <button id=\"first-action\">What is the difference between 5 and 3?</button>\n  </li>\n  <li>\n    <button id=\"second-action\">Wait 3 seconds</button>\n  </li>\n  <li>\n    <button id=\"terminate\">terminate() the Worker</button>\n  </li>\n</ul> It needs to execute the following script, either inline or as an external file: js // QueryableWorker instances methods:\n//   * sendQuery(queryable function name, argument to pass 1, argument to pass 2, etc. etc.): calls a Worker's queryable function\n//   * postMessage(string or JSON Data): see Worker.prototype.postMessage()\n//   * terminate(): terminates the Worker\n//   * addListener(name, function): adds a listener\n//   * removeListener(name): removes a listener\n// QueryableWorker instances properties:\n//   * defaultListener: the default listener executed only when the Worker calls the postMessage() function directly\nfunction QueryableWorker(url, defaultListener, onError) {\n  const worker = new Worker(url);\n  const listeners = {};\n\n  this.defaultListener = defaultListener ?? (() => {});\n\n  if (onError) {\n    worker.onerror = onError;\n  }\n\n  this.postMessage = (message) => {\n    worker.postMessage(message);\n  };\n\n  this.terminate = () => {\n    worker.terminate();\n  };\n\n  this.addListener = (name, listener) => {\n    listeners[name] = listener;\n  };\n\n  this.removeListener = (name) => {\n    delete listeners[name];\n  };\n\n  // This functions takes at least one argument, the method name we want to query.\n  // Then we can pass in the arguments that the method needs.\n  this.sendQuery = (queryMethod, ...queryMethodArguments) => {\n    if (!queryMethod) {\n      throw new TypeError(\n        \"QueryableWorker.sendQuery takes at least one argument\",\n      );\n    }\n    worker.postMessage({\n      queryMethod,\n      queryMethodArguments,\n    });\n  };\n\n  worker.onmessage = (event) => {\n    if (\n      event.data instanceof Object &&\n      Object.hasOwn(event.data, \"queryMethodListener\") &&\n      Object.hasOwn(event.data, \"queryMethodArguments\")\n    ) {\n      listeners[event.data.queryMethodListener].apply(\n        this,\n        event.data.queryMethodArguments,\n      );\n    } else {\n      this.defaultListener(event.data);\n    }\n  };\n}\n\n// your custom \"queryable\" worker\nconst myTask = new QueryableWorker(\"my_task.js\");\n\n// your custom \"listeners\"\nmyTask.addListener(\"printStuff\", (result) => {\n  document\n    .getElementById(\"firstLink\")\n    .parentNode.appendChild(\n      document.createTextNode(`The difference is ${result}!`),\n    );\n});\n\nmyTask.addListener(\"doAlert\", (time, unit) => {\n  alert(`Worker waited for ${time} ${unit} :-)`);\n});\n\ndocument.getElementById(\"first-action\").addEventListener(\"click\", () => {\n  myTask.sendQuery(\"getDifference\", 5, 3);\n});\ndocument.getElementById(\"second-action\").addEventListener(\"click\", () => {\n  myTask.sendQuery(\"waitSomeTime\");\n});\ndocument.getElementById(\"terminate\").addEventListener(\"click\", () => {\n  myTask.terminate();\n}); my_task.js (the worker): js const queryableFunctions = {\n  // example #1: get the difference between two numbers:\n  getDifference(minuend, subtrahend) {\n    reply(\"printStuff\", minuend - subtrahend);\n  },\n\n  // example #2: wait three seconds\n  waitSomeTime() {\n    setTimeout(() => {\n      reply(\"doAlert\", 3, \"seconds\");\n    }, 3000);\n  },\n};\n\n// system functions\n\nfunction defaultReply(message) {\n  // your default PUBLIC function executed only when main page calls the queryableWorker.postMessage() method directly\n  // do something\n}\n\nfunction reply(queryMethodListener, ...queryMethodArguments) {\n  if (!queryMethodListener) {\n    throw new TypeError(\"reply - not enough arguments\");\n  }\n  postMessage({\n    queryMethodListener,\n    queryMethodArguments,\n  });\n}\n\nonmessage = (event) => {\n  if (\n    event.data instanceof Object &&\n    Object.hasOwn(event.data, \"queryMethod\") &&\n    Object.hasOwn(event.data, \"queryMethodArguments\")\n  ) {\n    queryableFunctions[event.data.queryMethod].apply(\n      self,\n      event.data.queryMethodArguments,\n    );\n  } else {\n    defaultReply(event.data);\n  }\n}; It is possible to switch the content of each mainpage -> worker and worker -> mainpage message. And the property names \"queryMethod\", \"queryMethodListeners\", \"queryMethodArguments\" can be anything as long as they are consistent in QueryableWorker and the worker . Passing data by transferring ownership (transferable objects) Modern browsers contain an additional way to pass certain types of objects to or from a worker with high performance. Transferable objects are transferred from one context to another with a zero-copy operation, which results in a vast performance improvement when sending large data sets. For example, when transferring an ArrayBuffer from your main app to a worker script, the original ArrayBuffer is cleared and no longer usable. Its content is (quite literally) transferred to the worker context. js // Create a 32MB \"file\" and fill it with consecutive values from 0 to 255 \u2013 32MB = 1024 * 1024 * 32\nconst uInt8Array = new Uint8Array(1024 * 1024 * 32).map((v, i) => i);\nworker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]); Sharing data The SharedArrayBuffer object allows two threads, such as the worker and the main thread, to simultaneously operate on the same memory span and exchange data without going through the messaging mechanism. Using shared memory does come with significant determinism, security, and performance concerns, some of which are outlined in the JavaScript execution model article. Embedded workers There is not an \"official\" way to embed the code of a worker within a web page, like <script> elements do for normal scripts. But a <script> element that does not have a src attribute and has a type attribute that does not identify an executable MIME type can be considered a data block element that JavaScript could use. \"Data blocks\" is a more general feature of HTML that can carry almost any textual data. So, a worker could be embedded in this way: html <!doctype html>\n<html lang=\"en-US\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>MDN Example - Embedded worker</title>\n    <script type=\"text/js-worker\">\n      // This script WON'T be parsed by JS engines because its MIME type is text/js-worker.\n      const myVar = \"Hello World!\";\n      // Rest of your worker code goes here.\n    </script>\n    <script>\n      // This script WILL be parsed by JS engines because its MIME type is text/javascript.\n      function pageLog(sMsg) {\n        // Use a fragment: browser will only render/reflow once.\n        const frag = document.createDocumentFragment();\n        frag.appendChild(document.createTextNode(sMsg));\n        frag.appendChild(document.createElement(\"br\"));\n        document.querySelector(\"#logDisplay\").appendChild(frag);\n      }\n    </script>\n    <script type=\"text/js-worker\">\n      // This script WON'T be parsed by JS engines because its MIME type is text/js-worker.\n      onmessage = (event) => {\n        postMessage(myVar);\n      };\n      // Rest of your worker code goes here.\n    </script>\n    <script>\n      // This script WILL be parsed by JS engines because its MIME type is text/javascript.\n\n      // In the past blob builder existed, but now we use Blob\n      const blob = new Blob(\n        Array.prototype.map.call(\n          document.querySelectorAll(\"script[type='text/js-worker']\"),\n          (script) => script.textContent,\n        ),\n        { type: \"text/javascript\" },\n      );\n\n      // Creating a new global \"worker\" variable from all our \"text/js-worker\" scripts.\n      const worker = new Worker(window.URL.createObjectURL(blob));\n\n      worker.onmessage = (event) => {\n        pageLog(`Received: ${event.data}`);\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"logDisplay\"></div>\n    <script>\n      // Start the worker.\n      worker.postMessage(\"\");\n    </script>\n  </body>\n</html> The embedded worker is now nested into a new custom document.worker property. It is also worth noting that you can also convert a function into a Blob, then generate an object URL from that blob. For example: js function fn2workerURL(fn) {\n  const blob = new Blob([`(${fn.toString()})()`], { type: \"text/javascript\" });\n  return URL.createObjectURL(blob);\n} Further examples This section provides further examples of how to use web workers. Performing computations in the background Workers are mainly useful for allowing your code to perform processor-intensive calculations without blocking the user interface thread. In this example, a worker is used to calculate Fibonacci numbers. The JavaScript code The following JavaScript code is stored in the \"fibonacci.js\" file referenced by the HTML in the next section. js self.onmessage = (event) => {\n  const userNum = Number(event.data);\n  self.postMessage(fibonacci(userNum));\n};\n\nfunction fibonacci(num) {\n  let a = 1;\n  let b = 0;\n  while (num > 0) {\n    [a, b] = [a + b, a];\n    num--;\n  }\n\n  return b;\n} The worker sets the property onmessage to a function which will receive messages sent when the worker object's postMessage() is called. This performs the math and eventually returns the result back to the main thread. The HTML code html <form>\n  <div>\n    <label for=\"number\">\n      Enter a number that is a zero-based index position in the fibonacci\n      sequence to see what number is in that position. For example, enter 6 and\n      you'll get a result of 8 \u2014 the fibonacci number at index position 6 is 8.\n    </label>\n    <input type=\"number\" id=\"number\" />\n  </div>\n  <div>\n    <input type=\"submit\" />\n  </div>\n</form>\n\n<p id=\"result\"></p> It needs to execute the following script, either inline or as an external file: js const form = document.querySelector(\"form\");\nconst input = document.querySelector('input[type=\"number\"]');\nconst result = document.querySelector(\"p#result\");\nconst worker = new Worker(\"fibonacci.js\");\n\nworker.onmessage = (event) => {\n  result.textContent = event.data;\n  console.log(`Got: ${event.data}`);\n};\n\nworker.onerror = (error) => {\n  console.log(`Worker error: ${error.message}`);\n  throw error;\n};\n\nform.onsubmit = (e) => {\n  e.preventDefault();\n  worker.postMessage(input.value);\n  input.value = \"\";\n}; The web page creates a <p> element with the ID result , which gets used to display the result, then spawns the worker. After spawning the worker, the onmessage handler is configured to display the results by setting the contents of the <p> element, and the onerror handler is set to log the error message to the devtools console. Finally, a message is sent to the worker to start it. Try this example live . Dividing tasks among multiple workers As multicore computers become increasingly common, it's often useful to divide computationally complex tasks among multiple workers, which may then perform those tasks on multiple-processor cores. Other types of workers In addition to dedicated and shared web workers, there are other types of workers available: ServiceWorkers essentially act as proxy servers that sit between web applications, and the browser and network (when available). They are intended to (amongst other things) enable the creation of effective offline experiences, intercepting network requests and taking appropriate action based on whether the network is available and updated assets reside on the server. They will also allow access to push notifications and background sync APIs. Audio Worklet provide the ability for direct scripted audio processing to be done in a worklet (a lightweight version of worker) context. Debugging worker threads Most browsers enable you to debug web workers in their JavaScript debuggers in exactly the same way as debugging the main thread! For example, both Firefox and Chrome list JavaScript source files for both the main thread and active worker threads, and all of these files can be opened to set breakpoints and logpoints. To learn how to debug web workers, see the documentation for each browser's JavaScript debugger: Chrome Sources panel Firefox JavaScript Debugger To open devtools for web workers, you can use the following URLs: Edge: edge://inspect/ Chrome: chrome://inspect/ Firefox: about:debugging#/runtime/this-firefox These pages show an overview over all service workers. You need to find the relevant one by the URL and then click inspect to access devtools such as the console and debugger for that worker. Functions and interfaces available in workers You can use most standard JavaScript features inside a web worker, including: Navigator fetch() Array , Date , Math , and String setTimeout() and setInterval() The main thing you can't do in a Worker is directly affect the parent page. This includes manipulating the DOM and using that page's objects. You have to do it indirectly, by sending a message back to the main script via DedicatedWorkerGlobalScope.postMessage() , then doing the changes in event handler. Note: You can test whether a method or interface is available to workers using the Worker Playground . Note: For a complete list of functions available to workers, see Functions and interfaces available to workers . Specifications Specification HTML > # workers > See also Worker interface SharedWorker interface Functions available to workers OffscreenCanvas interface Help improve MDN Learn how to contribute This page was last modified on \u2068Sep 11, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content Web Workers API Guides Using Web Workers Functions and classes available to Web Workers The structured clone algorithm Transferable objects Interfaces DedicatedWorkerGlobalScope SharedWorker SharedWorkerGlobalScope Worker WorkerGlobalScope WorkerLocation WorkerNavigator Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation\u2019s not-for-profit parent, the Mozilla Foundation . Portions of this content are \u00a91998\u2013\u20682025\u2069 by individual mozilla.org contributors. Content available under a Creative Commons license .",
      "meta": {
        "viewport": "width=device-width, initial-scale=1.0",
        "description": "Web Workers are a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. In addition, they can make network requests using the fetch() or XMLHttpRequest APIs. Once created, a worker can send messages to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa).",
        "og:url": "https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers",
        "og:title": "Using Web Workers - Web APIs | MDN",
        "og:locale": "en_US",
        "og:description": "Web Workers are a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. In addition, they can make network requests using the fetch() or XMLHttpRequest APIs. Once created, a worker can send messages to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa).",
        "og:image": "https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png",
        "og:image:type": "image/png",
        "og:image:height": "1080",
        "og:image:width": "1920",
        "og:image:alt": "The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background.",
        "og:site_name": "MDN Web Docs",
        "twitter:card": "summary_large_image",
        "twitter:creator": "MozDevNet",
        "position": "4"
      },
      "keywords": [],
      "language": "en",
      "word_count": 4999,
      "description": "Web Workers are a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. In addition, they can make network requests using the fetch() or XMLHttpRequest APIs. Once created, a worker can send messages to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa).",
      "clean_text": "Using Web Workers Web Workers are a simple means for web content to run scripts in background threads. The worker thread can perform tasks without interfering with the user interface. In addition, they can make network requests using the fetch() or XMLHttpRequest APIs. Once created, a worker can send messages to the JavaScript code that created it by posting messages to an event handler specified by that code (and vice versa). This article provides a detailed introduction to using web workers. In this article Web Workers API Dedicated workers Shared workers About thread safety Content security policy Transferring data to and from workers: further details Embedded workers Further examples Other types of workers Debugging worker threads Functions and interfaces available in workers Specifications See also Web Workers API A worker is an object created using a constructor (e.g., Worker() ) that runs a named JavaScript file \u2014 this file contains the code that will run in the worker thread; workers run in another global context that is different from the current window . Thus, using the window shortcut to get the current global scope (instead of self ) within a Worker will return an error. The worker context is represented by a DedicatedWorkerGlobalScope object in the case of dedicated workers (standard workers that are utilized by a single script; shared workers use SharedWorkerGlobalScope ). A dedicated worker is only accessible from the script that first spawned it, whereas shared workers can be accessed from multiple scripts. Note: See The Web Workers API landing page for reference documentation on workers and additional guides. You can run whatever code you like inside the worker thread, with some exceptions. For example, you can't directly manipulate the DOM from inside a worker, or use some default methods and properties of the window object. But you can use a large number of items available under window , including WebSockets , and data storage mechanisms like IndexedDB . See Functions and classes available to workers for more details. Data is sent between workers and the main thread via a system of messages \u2014 both sides send their messages using the postMessage() method, and respond to messages via the onmessage event handler (the message is contained within the message event's data attribute). The data is copied rather than shared. Workers may in turn spawn new workers, as long as those workers are hosted within the same origin as the parent page. In addition, workers can make network requests using the fetch() or XMLHttpRequest APIs (although note that the responseXML attribute of XMLHttpRequest will always be null ). Dedicated workers As mentioned above, a dedicated worker is only accessible by the script that called it. In this section we'll discuss the JavaScript found in our Basic dedicated worker example ( run dedicated worker ): This allows you to enter two numbers to be multiplied together. The numbers are sent to a dedicated worker, multiplied together, and the result is returned to the page and displayed. This example is rather trivial, but we decided to keep it simple while introducing you to basic worker concepts. More advanced details are covered later on in the article. Worker feature detection For slightly more controlled error handling and backwards compatibility, it is a good idea to wrap your worker accessing code in the following ( main.js ): js if (window.Worker) {\n  // \u2026\n} Spawning a dedicated worker Creating a new worker is simple. All you need to do is call the Worker() constructor, specifying the URI of a script to execute in the worker thread ( main.js ): js const myWorker = new Worker(\"worker.js\"); Note: Bundlers, including webpack , Vite , and Parcel , recommend passing URLs that are resolved relative to import.meta.url to the Worker() constructor. For example: js const myWorker = new Worker(new URL(\"worker.js\", import.meta.url)); This way, the path is relative to the current script instead of the current HTML page, which allows the bundler to safely do optimizations like renaming (because otherwise the worker.js URL may point to a file not controlled by the bundler, so it cannot make any assumptions). Sending messages to and from a dedicated worker The magic of workers happens via the postMessage() method and the onmessage event handler. When you want to send a message to the worker, you post messages to it like this ( main.js ): js [first, second].forEach((input) => {\n  input.onchange = () => {\n    myWorker.postMessage([first.value, second.value]);\n    console.log(\"Message posted to worker\");\n  };\n}); So here we have two <input> elements represented by the variables first and second ; when the value of either is changed, myWorker.postMessage([first.value,second.value]) is used to send the value inside both to the worker, as an array. You can send pretty much anything you like in the message. In the worker, we can respond when the message is received by writing an event handler block like this ( worker.js ): js onmessage = (e) => {\n  console.log(\"Message received from main script\");\n  const workerResult = `Result: ${e.data[0] * e.data[1]}`;\n  console.log(\"Posting message back to main script\");\n  postMessage(workerResult);\n}; The onmessage handler allows us to run some code whenever a message is received, with the message itself being available in the message event's data attribute. Here we multiply together the two numbers then use postMessage() again, to post the result back to the main thread. Back in the main thread, we use onmessage again, to respond to the message sent back from the worker: js myWorker.onmessage = (e) => {\n  result.textContent = e.data;\n  console.log(\"Message received from worker\");\n}; Here we grab the message event data and set it as the textContent of the result paragraph, so the user can see the result of the calculation. Note: Notice that onmessage and postMessage() need to be hung off the Worker object when used in the main script thread, but not when used in the worker. This is because, inside the worker, the worker is effectively the global scope. Note: When a message is passed between the main thread and worker, it is copied or \"transferred\" (moved), not shared. Read Transferring data to and from workers: further details for a much more thorough explanation. Terminating a worker If you need to immediately terminate a running worker from the main thread, you can do so by calling the worker's terminate method: js myWorker.terminate(); The worker thread is killed immediately. Handling errors When a runtime error occurs in the worker, its onerror event handler is called. It receives an event named error which implements the ErrorEvent interface. The event doesn't bubble and is cancelable; to prevent the default action from taking place, the worker can call the error event's preventDefault() method. The error event has the following three fields that are of interest: message A human-readable error message. filename The name of the script file in which the error occurred. lineno The line number of the script file on which the error occurred. Spawning subworkers Workers may spawn more workers if they wish. So-called sub-workers must be hosted within the same origin as the parent page. Also, the URIs for subworkers are resolved relative to the parent worker's location rather than that of the owning page. This makes it easier for workers to keep track of where their dependencies are. Importing scripts and libraries Worker threads have access to a global function, importScripts() , which lets them import scripts. It accepts zero or more URIs as parameters to resources to import; all the following examples are valid: js importScripts(); /* imports nothing */\nimportScripts(\"foo.js\"); /* imports just \"foo.js\" */\nimportScripts(\"foo.js\", \"bar.js\"); /* imports two scripts */\nimportScripts(\n  \"//example.com/hello.js\",\n); /* You can import scripts from other origins */ The browser loads each listed script and executes it. Any global objects from each script may then be used by the worker. If the script can't be loaded, NETWORK_ERROR is thrown, and subsequent code will not be executed. Previously executed code (including code deferred using setTimeout() ) will still be functional though. Function declarations after the importScripts() method are also kept, since these are always evaluated before the rest of the code. Note: Scripts may be downloaded in any order, but will be executed in the order in which you pass the filenames into importScripts() . This is done synchronously; importScripts() does not return until all the scripts have been loaded and executed. Shared workers A shared worker is accessible by multiple scripts \u2014 even if they are being accessed by different windows, iframes or even workers. In this section we'll discuss the JavaScript found in our Basic shared worker example ( run shared worker ): This is very similar to the basic dedicated worker example, except that it has two functions available handled by different script files: multiplying two numbers , or squaring a number . Both scripts use the same worker to do the actual calculation required. Here we'll concentrate on the differences between dedicated and shared workers. Note that in this example we have two HTML pages, each with JavaScript applied that uses the same single worker file. Note: If SharedWorker can be accessed from several browsing contexts, all those browsing contexts must share the exact same origin (same protocol, host, and port). Note: In Firefox, shared workers cannot be shared between documents loaded in private and non-private windows ( Firefox bug 1177621 ). Spawning a shared worker Spawning a new shared worker is pretty much the same as with a dedicated worker, but with a different constructor name (see index.html and index2.html ) \u2014 each one has to spin up the worker using code like the following: js const myWorker = new SharedWorker(\"worker.js\"); One big difference is that with a shared worker you have to communicate via a port object \u2014 an explicit port is opened that the scripts can use to communicate with the worker (this is done implicitly in the case of dedicated workers). The port connection needs to be started either implicitly by use of the onmessage event handler or explicitly with the start() method before any messages can be posted. Calling start() is only needed if the message event is wired up via the addEventListener() method. Note: When using the start() method to open the port connection, it needs to be called from both the parent thread and the worker thread if two-way communication is needed. Sending messages to and from a shared worker Now messages can be sent to the worker as before, but the postMessage() method has to be invoked through the port object (again, you'll see similar constructs in both multiply.js and square.js ): js squareNumber.onchange = () => {\n  myWorker.port.postMessage([squareNumber.value, squareNumber.value]);\n  console.log(\"Message posted to worker\");\n}; Now, on to the worker. There is a bit more complexity here as well ( worker.js ): js onconnect = (e) => {\n  const port = e.ports[0];\n\n  port.onmessage = (e) => {\n    const workerResult = `Result: ${e.data[0] * e.data[1]}`;\n    port.postMessage(workerResult);\n  };\n}; First, we use an onconnect handler to fire code when a connection to the port happens (i.e., when the onmessage event handler in the parent thread is set up, or when the start() method is explicitly called in the parent thread). We use the ports attribute of this event object to grab the port and store it in a variable. Next, we add an onmessage handler on the port to do the calculation and return the result to the main thread. Setting up this onmessage handler in the worker thread also implicitly opens the port connection back to the parent thread, so the call to port.start() is not actually needed, as noted above. Finally, back in the main script, we deal with the message (again, you'll see similar constructs in both multiply.js and square.js ): js myWorker.port.onmessage = (e) => {\n  result2.textContent = e.data;\n  console.log(\"Message received from worker\");\n}; When a message comes back through the port from the worker, we insert the calculation result inside the appropriate result paragraph. About thread safety The Worker interface spawns real OS-level threads, and mindful programmers may be concerned that concurrency can cause \"interesting\" effects in your code if you aren't careful. However, since web workers have carefully controlled communication points with other threads, it's actually very hard to cause concurrency problems. There's no access to non-thread-safe components or the DOM. And you have to pass specific data in and out of a thread through serialized objects. So you have to work really hard to cause problems in your code. Content security policy Workers are considered to have their own execution context, distinct from the document that created them. For this reason they are, in general, not governed by the content security policy of the document (or parent worker) that created them. So for example, suppose a document is served with the following header: http Content-Security-Policy: script-src 'self' Among other things, this will prevent any scripts it includes from using eval() . However, if the script constructs a worker, code running in the worker's context will be allowed to use eval() . To specify a content security policy for the worker, set a Content-Security-Policy response header for the request which delivered the worker script itself. The exception to this is if the worker script's origin is a globally unique identifier (for example, if its URL has a scheme of data or blob). In this case, the worker does inherit the CSP of the document or worker that created it. Transferring data to and from workers: further details Data passed between the main page and workers is copied , not shared (except for certain objects that can be explicitly shared ). Objects are serialized as they're handed to the worker, and subsequently, de-serialized on the other end. The page and worker do not share the same instance , so the end result is that a duplicate is created on each end. Most browsers implement this feature as structured cloning . As you probably know by now, data is exchanged between the two threads via messages using postMessage() , and the message event's data attribute contains data passed back from the worker. example.html : (the main page): js const myWorker = new Worker(\"my_task.js\");\n\nmyWorker.onmessage = (event) => {\n  console.log(`Worker said : \"${event.data}\"`);\n};\n\nmyWorker.postMessage({ lastUpdate: new Date() }); my_task.js (the worker): js self.onmessage = (event) => {\n  postMessage(`Last updated: ${event.data.lastUpdate.toDateString()}`);\n}; The structured cloning algorithm can accept JSON and a few things that JSON can't \u2014 like circular references. Passing data examples Example 1: Advanced passing JSON Data and creating a switching system If you have to pass some complex data and have to call many different functions both on the main page and in the Worker, you can create a system which groups everything together. First, we create a QueryableWorker class that takes the URL of the worker, a default listener, and an error handler, and this class is going to keep track of a list of listeners and help us communicate with the worker: js function QueryableWorker(url, defaultListener, onError) {\n  const worker = new Worker(url);\n  const listeners = {};\n\n  this.defaultListener = defaultListener ?? (() => {});\n\n  if (onError) {\n    worker.onerror = onError;\n  }\n\n  this.postMessage = (message) => {\n    worker.postMessage(message);\n  };\n\n  this.terminate = () => {\n    worker.terminate();\n  };\n} Then we add the methods of adding/removing listeners: js this.addListeners = (name, listener) => {\n  listeners[name] = listener;\n};\n\nthis.removeListeners = (name) => {\n  delete listeners[name];\n}; Here we let the worker handle two simple operations for illustration: getting the difference of two numbers and making an alert after three seconds. In order to achieve that we first implement a sendQuery method which queries if the worker actually has the corresponding methods to do what we want. js // This functions takes at least one argument, the method name we want to query.\n// Then we can pass in the arguments that the method needs.\nthis.sendQuery = (queryMethod, ...queryMethodArguments) => {\n  if (!queryMethod) {\n    throw new TypeError(\n      \"QueryableWorker.sendQuery takes at least one argument\",\n    );\n  }\n  worker.postMessage({\n    queryMethod,\n    queryMethodArguments,\n  });\n}; We finish QueryableWorker with the onmessage method. If the worker has the corresponding methods we queried, it should return the name of the corresponding listener and the arguments it needs, we just need to find it in listeners .: js worker.onmessage = (event) => {\n  if (\n    event.data instanceof Object &&\n    Object.hasOwn(event.data, \"queryMethodListener\") &&\n    Object.hasOwn(event.data, \"queryMethodArguments\")\n  ) {\n    listeners[event.data.queryMethodListener].apply(\n      this,\n      event.data.queryMethodArguments,\n    );\n  } else {\n    this.defaultListener(event.data);\n  }\n}; Now onto the worker. First we need to have the methods to handle the two simple operations: js const queryableFunctions = {\n  getDifference(a, b) {\n    reply(\"printStuff\", a - b);\n  },\n  waitSomeTime() {\n    setTimeout(() => {\n      reply(\"doAlert\", 3, \"seconds\");\n    }, 3000);\n  },\n};\n\nfunction reply(queryMethodListener, ...queryMethodArguments) {\n  if (!queryMethodListener) {\n    throw new TypeError(\"reply - takes at least one argument\");\n  }\n  postMessage({\n    queryMethodListener,\n    queryMethodArguments,\n  });\n}\n\n// This method is called when main page calls QueryWorker's postMessage\n// method directly\nfunction defaultReply(message) {\n  // do something\n} And the onmessage method is now trivial: js onmessage = (event) => {\n  if (\n    event.data instanceof Object &&\n    Object.hasOwn(event.data, \"queryMethod\") &&\n    Object.hasOwn(event.data, \"queryMethodArguments\")\n  ) {\n    queryableFunctions[event.data.queryMethod].apply(\n      self,\n      event.data.queryMethodArguments,\n    );\n  } else {\n    defaultReply(event.data);\n  }\n}; Here are the full implementation: example.html (the main page): html <ul>\n  <li>\n    <button id=\"first-action\">What is the difference between 5 and 3?</button>\n  </li>\n  <li>\n    <button id=\"second-action\">Wait 3 seconds</button>\n  </li>\n  <li>\n    <button id=\"terminate\">terminate() the Worker</button>\n  </li>\n</ul> It needs to execute the following script, either inline or as an external file: js // QueryableWorker instances methods:\n//   * sendQuery(queryable function name, argument to pass 1, argument to pass 2, etc. etc.): calls a Worker's queryable function\n//   * postMessage(string or JSON Data): see Worker.prototype.postMessage()\n//   * terminate(): terminates the Worker\n//   * addListener(name, function): adds a listener\n//   * removeListener(name): removes a listener\n// QueryableWorker instances properties:\n//   * defaultListener: the default listener executed only when the Worker calls the postMessage() function directly\nfunction QueryableWorker(url, defaultListener, onError) {\n  const worker = new Worker(url);\n  const listeners = {};\n\n  this.defaultListener = defaultListener ?? (() => {});\n\n  if (onError) {\n    worker.onerror = onError;\n  }\n\n  this.postMessage = (message) => {\n    worker.postMessage(message);\n  };\n\n  this.terminate = () => {\n    worker.terminate();\n  };\n\n  this.addListener = (name, listener) => {\n    listeners[name] = listener;\n  };\n\n  this.removeListener = (name) => {\n    delete listeners[name];\n  };\n\n  // This functions takes at least one argument, the method name we want to query.\n  // Then we can pass in the arguments that the method needs.\n  this.sendQuery = (queryMethod, ...queryMethodArguments) => {\n    if (!queryMethod) {\n      throw new TypeError(\n        \"QueryableWorker.sendQuery takes at least one argument\",\n      );\n    }\n    worker.postMessage({\n      queryMethod,\n      queryMethodArguments,\n    });\n  };\n\n  worker.onmessage = (event) => {\n    if (\n      event.data instanceof Object &&\n      Object.hasOwn(event.data, \"queryMethodListener\") &&\n      Object.hasOwn(event.data, \"queryMethodArguments\")\n    ) {\n      listeners[event.data.queryMethodListener].apply(\n        this,\n        event.data.queryMethodArguments,\n      );\n    } else {\n      this.defaultListener(event.data);\n    }\n  };\n}\n\n// your custom \"queryable\" worker\nconst myTask = new QueryableWorker(\"my_task.js\");\n\n// your custom \"listeners\"\nmyTask.addListener(\"printStuff\", (result) => {\n  document\n    .getElementById(\"firstLink\")\n    .parentNode.appendChild(\n      document.createTextNode(`The difference is ${result}!`),\n    );\n});\n\nmyTask.addListener(\"doAlert\", (time, unit) => {\n  alert(`Worker waited for ${time} ${unit} :-)`);\n});\n\ndocument.getElementById(\"first-action\").addEventListener(\"click\", () => {\n  myTask.sendQuery(\"getDifference\", 5, 3);\n});\ndocument.getElementById(\"second-action\").addEventListener(\"click\", () => {\n  myTask.sendQuery(\"waitSomeTime\");\n});\ndocument.getElementById(\"terminate\").addEventListener(\"click\", () => {\n  myTask.terminate();\n}); my_task.js (the worker): js const queryableFunctions = {\n  // example #1: get the difference between two numbers:\n  getDifference(minuend, subtrahend) {\n    reply(\"printStuff\", minuend - subtrahend);\n  },\n\n  // example #2: wait three seconds\n  waitSomeTime() {\n    setTimeout(() => {\n      reply(\"doAlert\", 3, \"seconds\");\n    }, 3000);\n  },\n};\n\n// system functions\n\nfunction defaultReply(message) {\n  // your default PUBLIC function executed only when main page calls the queryableWorker.postMessage() method directly\n  // do something\n}\n\nfunction reply(queryMethodListener, ...queryMethodArguments) {\n  if (!queryMethodListener) {\n    throw new TypeError(\"reply - not enough arguments\");\n  }\n  postMessage({\n    queryMethodListener,\n    queryMethodArguments,\n  });\n}\n\nonmessage = (event) => {\n  if (\n    event.data instanceof Object &&\n    Object.hasOwn(event.data, \"queryMethod\") &&\n    Object.hasOwn(event.data, \"queryMethodArguments\")\n  ) {\n    queryableFunctions[event.data.queryMethod].apply(\n      self,\n      event.data.queryMethodArguments,\n    );\n  } else {\n    defaultReply(event.data);\n  }\n}; It is possible to switch the content of each mainpage -> worker and worker -> mainpage message. And the property names \"queryMethod\", \"queryMethodListeners\", \"queryMethodArguments\" can be anything as long as they are consistent in QueryableWorker and the worker . Passing data by transferring ownership (transferable objects) Modern browsers contain an additional way to pass certain types of objects to or from a worker with high performance. Transferable objects are transferred from one context to another with a zero-copy operation, which results in a vast performance improvement when sending large data sets. For example, when transferring an ArrayBuffer from your main app to a worker script, the original ArrayBuffer is cleared and no longer usable. Its content is (quite literally) transferred to the worker context. js // Create a 32MB \"file\" and fill it with consecutive values from 0 to 255 \u2013 32MB = 1024 * 1024 * 32\nconst uInt8Array = new Uint8Array(1024 * 1024 * 32).map((v, i) => i);\nworker.postMessage(uInt8Array.buffer, [uInt8Array.buffer]); Sharing data The SharedArrayBuffer object allows two threads, such as the worker and the main thread, to simultaneously operate on the same memory span and exchange data without going through the messaging mechanism. Using shared memory does come with significant determinism, security, and performance concerns, some of which are outlined in the JavaScript execution model article. Embedded workers There is not an \"official\" way to embed the code of a worker within a web page, like <script> elements do for normal scripts. But a <script> element that does not have a src attribute and has a type attribute that does not identify an executable MIME type can be considered a data block element that JavaScript could use. \"Data blocks\" is a more general feature of HTML that can carry almost any textual data. So, a worker could be embedded in this way: html <!doctype html>\n<html lang=\"en-US\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width\" />\n    <title>MDN Example - Embedded worker</title>\n    <script type=\"text/js-worker\">\n      // This script WON'T be parsed by JS engines because its MIME type is text/js-worker.\n      const myVar = \"Hello World!\";\n      // Rest of your worker code goes here.\n    </script>\n    <script>\n      // This script WILL be parsed by JS engines because its MIME type is text/javascript.\n      function pageLog(sMsg) {\n        // Use a fragment: browser will only render/reflow once.\n        const frag = document.createDocumentFragment();\n        frag.appendChild(document.createTextNode(sMsg));\n        frag.appendChild(document.createElement(\"br\"));\n        document.querySelector(\"#logDisplay\").appendChild(frag);\n      }\n    </script>\n    <script type=\"text/js-worker\">\n      // This script WON'T be parsed by JS engines because its MIME type is text/js-worker.\n      onmessage = (event) => {\n        postMessage(myVar);\n      };\n      // Rest of your worker code goes here.\n    </script>\n    <script>\n      // This script WILL be parsed by JS engines because its MIME type is text/javascript.\n\n      // In the past blob builder existed, but now we use Blob\n      const blob = new Blob(\n        Array.prototype.map.call(\n          document.querySelectorAll(\"script[type='text/js-worker']\"),\n          (script) => script.textContent,\n        ),\n        { type: \"text/javascript\" },\n      );\n\n      // Creating a new global \"worker\" variable from all our \"text/js-worker\" scripts.\n      const worker = new Worker(window.URL.createObjectURL(blob));\n\n      worker.onmessage = (event) => {\n        pageLog(`Received: ${event.data}`);\n      };\n    </script>\n  </head>\n  <body>\n    <div id=\"logDisplay\"></div>\n    <script>\n      // Start the worker.\n      worker.postMessage(\"\");\n    </script>\n  </body>\n</html> The embedded worker is now nested into a new custom document.worker property. It is also worth noting that you can also convert a function into a Blob, then generate an object URL from that blob. For example: js function fn2workerURL(fn) {\n  const blob = new Blob([`(${fn.toString()})()`], { type: \"text/javascript\" });\n  return URL.createObjectURL(blob);\n} Further examples This section provides further examples of how to use web workers. Performing computations in the background Workers are mainly useful for allowing your code to perform processor-intensive calculations without blocking the user interface thread. In this example, a worker is used to calculate Fibonacci numbers. The JavaScript code The following JavaScript code is stored in the \"fibonacci.js\" file referenced by the HTML in the next section. js self.onmessage = (event) => {\n  const userNum = Number(event.data);\n  self.postMessage(fibonacci(userNum));\n};\n\nfunction fibonacci(num) {\n  let a = 1;\n  let b = 0;\n  while (num > 0) {\n    [a, b] = [a + b, a];\n    num--;\n  }\n\n  return b;\n} The worker sets the property onmessage to a function which will receive messages sent when the worker object's postMessage() is called. This performs the math and eventually returns the result back to the main thread. The HTML code html <form>\n  <div>\n    <label for=\"number\">\n      Enter a number that is a zero-based index position in the fibonacci\n      sequence to see what number is in that position. For example, enter 6 and\n      you'll get a result of 8 \u2014 the fibonacci number at index position 6 is 8.\n    </label>\n    <input type=\"number\" id=\"number\" />\n  </div>\n  <div>\n    <input type=\"submit\" />\n  </div>\n</form>\n\n<p id=\"result\"></p> It needs to execute the following script, either inline or as an external file: js const form = document.querySelector(\"form\");\nconst input = document.querySelector('input[type=\"number\"]');\nconst result = document.querySelector(\"p#result\");\nconst worker = new Worker(\"fibonacci.js\");\n\nworker.onmessage = (event) => {\n  result.textContent = event.data;\n  console.log(`Got: ${event.data}`);\n};\n\nworker.onerror = (error) => {\n  console.log(`Worker error: ${error.message}`);\n  throw error;\n};\n\nform.onsubmit = (e) => {\n  e.preventDefault();\n  worker.postMessage(input.value);\n  input.value = \"\";\n}; The web page creates a <p> element with the ID result , which gets used to display the result, then spawns the worker. After spawning the worker, the onmessage handler is configured to display the results by setting the contents of the <p> element, and the onerror handler is set to log the error message to the devtools console. Finally, a message is sent to the worker to start it. Try this example live . Dividing tasks among multiple workers As multicore computers become increasingly common, it's often useful to divide computationally complex tasks among multiple workers, which may then perform those tasks on multiple-processor cores. Other types of workers In addition to dedicated and shared web workers, there are other types of workers available: ServiceWorkers essentially act as proxy servers that sit between web applications, and the browser and network (when available). They are intended to (amongst other things) enable the creation of effective offline experiences, intercepting network requests and taking appropriate action based on whether the network is available and updated assets reside on the server. They will also allow access to push notifications and background sync APIs. Audio Worklet provide the ability for direct scripted audio processing to be done in a worklet (a lightweight version of worker) context. Debugging worker threads Most browsers enable you to debug web workers in their JavaScript debuggers in exactly the same way as debugging the main thread! For example, both Firefox and Chrome list JavaScript source files for both the main thread and active worker threads, and all of these files can be opened to set breakpoints and logpoints. To learn how to debug web workers, see the documentation for each browser's JavaScript debugger: Chrome Sources panel Firefox JavaScript Debugger To open devtools for web workers, you can use the following URLs: Edge: edge://inspect/ Chrome: chrome://inspect/ Firefox: about:debugging#/runtime/this-firefox These pages show an overview over all service workers. You need to find the relevant one by the URL and then click inspect to access devtools such as the console and debugger for that worker. Functions and interfaces available in workers You can use most standard JavaScript features inside a web worker, including: Navigator fetch() Array , Date , Math , and String setTimeout() and setInterval() The main thing you can't do in a Worker is directly affect the parent page. This includes manipulating the DOM and using that page's objects. You have to do it indirectly, by sending a message back to the main script via DedicatedWorkerGlobalScope.postMessage() , then doing the changes in event handler. Note: You can test whether a method or interface is available to workers using the Worker Playground . Note: For a complete list of functions available to workers, see Functions and interfaces available to workers . Specifications Specification HTML > # workers > See also Worker interface SharedWorker interface Functions available to workers OffscreenCanvas interface Help improve MDN Learn how to contribute This page was last modified on \u2068Sep 11, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content"
    }
  },
  "metadata": {
    "jsonld": [],
    "microdata": [],
    "opengraph": {},
    "twitter": {
      "card": "summary_large_image",
      "creator": "MozDevNet"
    }
  },
  "timestamp": "2025-12-04T13:38:19.203593"
}