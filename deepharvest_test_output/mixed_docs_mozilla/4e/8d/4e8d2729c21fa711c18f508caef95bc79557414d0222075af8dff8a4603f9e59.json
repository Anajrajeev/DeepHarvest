{
  "url": "https://developer.mozilla.org/en-US/docs/Web/API/File_System_API",
  "content": {
    "text": {
      "title": "File System API - Web APIs | MDN",
      "text": "File System API - Web APIs | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all\u2026 HTML guides Responsive images HTML cheatsheet Date & time formats See all\u2026 Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values See all\u2026 CSS guides Box model Animations Flexbox Colors See all\u2026 Layout cookbook Column layouts Centering an element Card component See all\u2026 JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all\u2026 JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all\u2026 Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all\u2026 Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all\u2026 Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started modules Core modules MDN Curriculum Learn HTML Structuring content with HTML module Learn CSS CSS styling basics module CSS layout module Learn JavaScript Dynamic scripting with JavaScript module Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Web Web APIs File System API File System API Secure context: This feature is available only in secure contexts (HTTPS), in some or all supporting browsers . Note: This feature is available in Web Workers . The File System API \u2014 with extensions provided via the File System Access API to access files on the device file system \u2014 allows read, write and file management capabilities. See Relationship to other file-related APIs for a comparison between this API, the File and Directory Entries API , and the File API . In this article Concepts and Usage Interfaces Examples Specifications Browser compatibility See also Concepts and Usage This API allows interaction with files on a user's local device, or on a user-accessible network file system. Core functionality of this API includes reading files, writing or saving files, and access to directory structure. Most of the interaction with files and directories is accomplished through handles. A parent FileSystemHandle class helps define two child classes: FileSystemFileHandle and FileSystemDirectoryHandle , for files and directories respectively. The handles represent a file or directory on the user's system. You can first gain access to them by showing the user a file or directory picker using methods such as window.showOpenFilePicker() and window.showDirectoryPicker() . Once these are called, the file picker presents itself and the user selects either a file or directory. Once this happens successfully, a handle is returned. You can also gain access to file handles via: The DataTransferItem.getAsFileSystemHandle() method of the HTML Drag and Drop API . The File Handling API . Each handle provides its own functionality and there are a few differences depending on which one you are using (see the interfaces section for specific details). You then can access file data, or information (including children) of the directory selected. This API opens up potential functionality the web has been lacking. Still, security has been of utmost concern when designing the API, and access to file/directory data is disallowed unless the user specifically permits it (note that this is not the case with the Origin private file system , because it is not visible to the user). Note: The different exceptions that can be thrown when using the features of this API are listed on relevant pages as defined in the spec. However, the situation is made more complex by the interaction of the API and the underlying operating system. A proposal has been made to list the error mappings in the spec , which includes useful related information. Note: Objects based on FileSystemHandle can also be serialized into an IndexedDB database instance, or transferred via postMessage() . Origin private file system The origin private file system (OPFS) is a storage endpoint provided as part of the File System API, which is private to the origin of the page and not visible to the user like the regular file system. It provides access to a special kind of file that is highly optimized for performance and offers in-place write access to its content. The following are some possible use cases: Apps with persistent uploader When a file or directory is selected for upload, you can copy the file into a local sandbox and upload a chunk at a time. The app can restart uploads after an interruption, such as the browser being closed or crashing, connectivity getting interrupted, or the computer getting shut down. Video game or other apps with lots of media assets The app downloads one or several large tarballs and expands them locally into a directory structure. The app pre-fetches assets in the background, so the user can go to the next task or game level without waiting for a download. Audio or photo editor with offline access or local cache (great for performance and speed) The app can write to files in place (for example, overwriting just the ID3/EXIF tags and not the entire file). Offline video viewer The app can download large files (>1GB) for later viewing. The app can access partially downloaded files (so that you can watch the first chapter of your DVD, even if the app is still downloading the rest of the content or if the app didn't complete the download because you had to run to catch a train). Offline web mail client The client downloads attachments and stores them locally. The client caches attachments for later upload. Read our Origin private file system for instructions on how to use it. Saving files In the case of the asynchronous handles, use the FileSystemWritableFileStream interface. Once the data you'd like to save is in a format of Blob , String object, string literal or buffer , you can open a stream and save the data to a file. This can be the existing file or a new file. In the case of the synchronous FileSystemSyncAccessHandle , you write changes to a file using the write() method. You can optionally also call flush() if you need the changes committed to disk at a specific time (otherwise you can leave the underlying operating system to handle this when it sees fit, which should be OK in most cases). Interfaces FileSystemChangeRecord Experimental Contains details of a single change observed by a FileSystemObserver . FileSystemHandle An object which represents a file or directory entry. Multiple handles can represent the same entry. For the most part you do not work with FileSystemHandle directly but rather its child interfaces FileSystemFileHandle and FileSystemDirectoryHandle . FileSystemFileHandle Provides a handle to a file system entry. FileSystemDirectoryHandle Provides a handle to a file system directory. FileSystemObserver Experimental Provides a mechanism to observe changes to selected files or directories. FileSystemSyncAccessHandle Provides a synchronous handle to a file system entry, which operates in-place on a single file on disk. The synchronous nature of the file reads and writes allows for higher performance for critical methods in contexts where asynchronous operations come with high overhead, e.g., WebAssembly . This class is only accessible inside dedicated Web Workers for files within the origin private file system . FileSystemWritableFileStream A WritableStream object with additional convenience methods, which operates on a single file on disk. Extensions to other interfaces Window.showDirectoryPicker() Displays a directory picker which allows the user to select a directory. Window.showOpenFilePicker() Shows a file picker that allows a user to select a file or multiple files. Window.showSaveFilePicker() Shows a file picker that allows a user to save a file. DataTransferItem.getAsFileSystemHandle() Returns a Promise that fulfills with a FileSystemFileHandle if the dragged item is a file, or fulfills with a FileSystemDirectoryHandle if the dragged item is a directory. StorageManager.getDirectory() Used to obtain a reference to a FileSystemDirectoryHandle object allowing access to a directory and its contents, stored in the origin private file system . Returns a Promise that fulfills with a FileSystemDirectoryHandle object. Examples > Accessing files The below code allows the user to choose a file from the file picker. js async function getFile() {\n  // Open file picker and destructure the result the first handle\n  const [fileHandle] = await window.showOpenFilePicker();\n  const file = await fileHandle.getFile();\n  return file;\n} The following asynchronous function presents a file picker and once a file is chosen, uses the getFile() method to retrieve the contents. js const pickerOpts = {\n  types: [\n    {\n      description: \"Images\",\n      accept: {\n        \"image/*\": [\".png\", \".gif\", \".jpeg\", \".jpg\"],\n      },\n    },\n  ],\n  excludeAcceptAllOption: true,\n  multiple: false,\n};\n\nasync function getTheFile() {\n  // Open file picker and destructure the result the first handle\n  const [fileHandle] = await window.showOpenFilePicker(pickerOpts);\n\n  // get file contents\n  const fileData = await fileHandle.getFile();\n} Accessing directories The following example returns a directory handle with the specified name. If the directory does not exist, it is created. js const dirName = \"directoryToGetName\";\n\n// assuming we have a directory handle: 'currentDirHandle'\nconst subDir = await currentDirHandle.getDirectoryHandle(dirName, {\n  create: true,\n}); The following asynchronous function uses resolve() to find the path to a chosen file, relative to a specified directory handle. js async function returnPathDirectories(directoryHandle) {\n  // Get a file handle by showing a file picker:\n  const [handle] = await self.showOpenFilePicker();\n  if (!handle) {\n    // User cancelled, or otherwise failed to open a file.\n    return;\n  }\n\n  // Check if handle exists inside our directory handle\n  const relativePaths = await directoryHandle.resolve(handle);\n\n  if (relativePaths === null) {\n    // Not inside directory handle\n  } else {\n    // relativePaths is an array of names, giving the relative path\n\n    for (const name of relativePaths) {\n      // log each entry\n      console.log(name);\n    }\n  }\n} Writing to files The following asynchronous function opens the save file picker, which returns a FileSystemFileHandle once a file is selected. A writable stream is then created using the FileSystemFileHandle.createWritable() method. A user defined Blob is then written to the stream which is subsequently closed. js async function saveFile() {\n  // create a new handle\n  const newHandle = await window.showSaveFilePicker();\n\n  // create a FileSystemWritableFileStream to write to\n  const writableStream = await newHandle.createWritable();\n\n  // write our file\n  await writableStream.write(imgBlob);\n\n  // close the file and write the contents to disk.\n  await writableStream.close();\n} The following show different examples of options that can be passed into the write() method. js // just pass in the data (no options)\nwritableStream.write(data);\n\n// writes the data to the stream from the determined position\nwritableStream.write({ type: \"write\", position, data });\n\n// updates the current file cursor offset to the position specified\nwritableStream.write({ type: \"seek\", position });\n\n// resizes the file to be size bytes long\nwritableStream.write({ type: \"truncate\", size }); Synchronously reading and writing files in OPFS This example synchronously reads and writes a file to the origin private file system . The following asynchronous event handler function is contained inside a Web Worker. On receiving a message from the main thread it: Creates a synchronous file access handle. Gets the size of the file and creates an ArrayBuffer to contain it. Reads the file contents into the buffer. Encodes the message and writes it to the end of the file. Persists the changes to disk and closes the access handle. js onmessage = async (e) => {\n  // retrieve message sent to work from main script\n  const message = e.data;\n\n  // Get handle to draft file in OPFS\n  const root = await navigator.storage.getDirectory();\n  const draftHandle = await root.getFileHandle(\"draft.txt\", { create: true });\n  // Get sync access handle\n  const accessHandle = await draftHandle.createSyncAccessHandle();\n\n  // Get size of the file.\n  const fileSize = accessHandle.getSize();\n  // Read file content to a buffer.\n  const buffer = new DataView(new ArrayBuffer(fileSize));\n  const readBuffer = accessHandle.read(buffer, { at: 0 });\n\n  // Write the message to the end of the file.\n  const encoder = new TextEncoder();\n  const encodedMessage = encoder.encode(message);\n  const writeBuffer = accessHandle.write(encodedMessage, { at: readBuffer });\n\n  // Persist changes to disk.\n  accessHandle.flush();\n\n  // Always close FileSystemSyncAccessHandle if done.\n  accessHandle.close();\n}; Note: In earlier versions of the spec, close() , flush() , getSize() , and truncate() were unergonomically specified as asynchronous methods. This has now been amended , but some browsers still support the asynchronous versions. Specifications Specification File System > File System Access > Browser compatibility > api.FileSystemHandle api.FileSystemFileHandle api.FileSystemDirectoryHandle api.FileSystemWritableFileStream api.FileSystemSyncAccessHandle See also The File System Access API: simplifying access to local files The origin private file system Help improve MDN Learn how to contribute This page was last modified on \u2068Oct 20, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content File System API Guides Origin private file system Interfaces FileSystemChangeRecord FileSystemHandle FileSystemFileHandle FileSystemDirectoryHandle FileSystemObserver Experimental Non-standard FileSystemSyncAccessHandle FileSystemWritableFileStream Methods Window .showOpenFilePicker() Experimental Window .showSaveFilePicker() Experimental Window .showDirectoryPicker() Experimental DataTransferItem .getAsFileSystemHandle() Experimental StorageManager .getDirectory() Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation\u2019s not-for-profit parent, the Mozilla Foundation . Portions of this content are \u00a91998\u2013\u20682025\u2069 by individual mozilla.org contributors. Content available under a Creative Commons license .",
      "meta": {
        "viewport": "width=device-width, initial-scale=1.0",
        "description": "The File System API \u2014 with extensions provided via the File System Access API to access files on the device file system \u2014 allows read, write and file management capabilities.",
        "og:url": "https://developer.mozilla.org/en-US/docs/Web/API/File_System_API",
        "og:title": "File System API - Web APIs | MDN",
        "og:locale": "en_US",
        "og:description": "The File System API \u2014 with extensions provided via the File System Access API to access files on the device file system \u2014 allows read, write and file management capabilities.",
        "og:image": "https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png",
        "og:image:type": "image/png",
        "og:image:height": "1080",
        "og:image:width": "1920",
        "og:image:alt": "The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background.",
        "og:site_name": "MDN Web Docs",
        "twitter:card": "summary_large_image",
        "twitter:creator": "MozDevNet",
        "position": "3"
      },
      "keywords": [],
      "language": "en",
      "word_count": 2247,
      "description": "The File System API \u2014 with extensions provided via the File System Access API to access files on the device file system \u2014 allows read, write and file management capabilities.",
      "clean_text": "File System API Secure context: This feature is available only in secure contexts (HTTPS), in some or all supporting browsers . Note: This feature is available in Web Workers . The File System API \u2014 with extensions provided via the File System Access API to access files on the device file system \u2014 allows read, write and file management capabilities. See Relationship to other file-related APIs for a comparison between this API, the File and Directory Entries API , and the File API . In this article Concepts and Usage Interfaces Examples Specifications Browser compatibility See also Concepts and Usage This API allows interaction with files on a user's local device, or on a user-accessible network file system. Core functionality of this API includes reading files, writing or saving files, and access to directory structure. Most of the interaction with files and directories is accomplished through handles. A parent FileSystemHandle class helps define two child classes: FileSystemFileHandle and FileSystemDirectoryHandle , for files and directories respectively. The handles represent a file or directory on the user's system. You can first gain access to them by showing the user a file or directory picker using methods such as window.showOpenFilePicker() and window.showDirectoryPicker() . Once these are called, the file picker presents itself and the user selects either a file or directory. Once this happens successfully, a handle is returned. You can also gain access to file handles via: The DataTransferItem.getAsFileSystemHandle() method of the HTML Drag and Drop API . The File Handling API . Each handle provides its own functionality and there are a few differences depending on which one you are using (see the interfaces section for specific details). You then can access file data, or information (including children) of the directory selected. This API opens up potential functionality the web has been lacking. Still, security has been of utmost concern when designing the API, and access to file/directory data is disallowed unless the user specifically permits it (note that this is not the case with the Origin private file system , because it is not visible to the user). Note: The different exceptions that can be thrown when using the features of this API are listed on relevant pages as defined in the spec. However, the situation is made more complex by the interaction of the API and the underlying operating system. A proposal has been made to list the error mappings in the spec , which includes useful related information. Note: Objects based on FileSystemHandle can also be serialized into an IndexedDB database instance, or transferred via postMessage() . Origin private file system The origin private file system (OPFS) is a storage endpoint provided as part of the File System API, which is private to the origin of the page and not visible to the user like the regular file system. It provides access to a special kind of file that is highly optimized for performance and offers in-place write access to its content. The following are some possible use cases: Apps with persistent uploader When a file or directory is selected for upload, you can copy the file into a local sandbox and upload a chunk at a time. The app can restart uploads after an interruption, such as the browser being closed or crashing, connectivity getting interrupted, or the computer getting shut down. Video game or other apps with lots of media assets The app downloads one or several large tarballs and expands them locally into a directory structure. The app pre-fetches assets in the background, so the user can go to the next task or game level without waiting for a download. Audio or photo editor with offline access or local cache (great for performance and speed) The app can write to files in place (for example, overwriting just the ID3/EXIF tags and not the entire file). Offline video viewer The app can download large files (>1GB) for later viewing. The app can access partially downloaded files (so that you can watch the first chapter of your DVD, even if the app is still downloading the rest of the content or if the app didn't complete the download because you had to run to catch a train). Offline web mail client The client downloads attachments and stores them locally. The client caches attachments for later upload. Read our Origin private file system for instructions on how to use it. Saving files In the case of the asynchronous handles, use the FileSystemWritableFileStream interface. Once the data you'd like to save is in a format of Blob , String object, string literal or buffer , you can open a stream and save the data to a file. This can be the existing file or a new file. In the case of the synchronous FileSystemSyncAccessHandle , you write changes to a file using the write() method. You can optionally also call flush() if you need the changes committed to disk at a specific time (otherwise you can leave the underlying operating system to handle this when it sees fit, which should be OK in most cases). Interfaces FileSystemChangeRecord Experimental Contains details of a single change observed by a FileSystemObserver . FileSystemHandle An object which represents a file or directory entry. Multiple handles can represent the same entry. For the most part you do not work with FileSystemHandle directly but rather its child interfaces FileSystemFileHandle and FileSystemDirectoryHandle . FileSystemFileHandle Provides a handle to a file system entry. FileSystemDirectoryHandle Provides a handle to a file system directory. FileSystemObserver Experimental Provides a mechanism to observe changes to selected files or directories. FileSystemSyncAccessHandle Provides a synchronous handle to a file system entry, which operates in-place on a single file on disk. The synchronous nature of the file reads and writes allows for higher performance for critical methods in contexts where asynchronous operations come with high overhead, e.g., WebAssembly . This class is only accessible inside dedicated Web Workers for files within the origin private file system . FileSystemWritableFileStream A WritableStream object with additional convenience methods, which operates on a single file on disk. Extensions to other interfaces Window.showDirectoryPicker() Displays a directory picker which allows the user to select a directory. Window.showOpenFilePicker() Shows a file picker that allows a user to select a file or multiple files. Window.showSaveFilePicker() Shows a file picker that allows a user to save a file. DataTransferItem.getAsFileSystemHandle() Returns a Promise that fulfills with a FileSystemFileHandle if the dragged item is a file, or fulfills with a FileSystemDirectoryHandle if the dragged item is a directory. StorageManager.getDirectory() Used to obtain a reference to a FileSystemDirectoryHandle object allowing access to a directory and its contents, stored in the origin private file system . Returns a Promise that fulfills with a FileSystemDirectoryHandle object. Examples > Accessing files The below code allows the user to choose a file from the file picker. js async function getFile() {\n  // Open file picker and destructure the result the first handle\n  const [fileHandle] = await window.showOpenFilePicker();\n  const file = await fileHandle.getFile();\n  return file;\n} The following asynchronous function presents a file picker and once a file is chosen, uses the getFile() method to retrieve the contents. js const pickerOpts = {\n  types: [\n    {\n      description: \"Images\",\n      accept: {\n        \"image/*\": [\".png\", \".gif\", \".jpeg\", \".jpg\"],\n      },\n    },\n  ],\n  excludeAcceptAllOption: true,\n  multiple: false,\n};\n\nasync function getTheFile() {\n  // Open file picker and destructure the result the first handle\n  const [fileHandle] = await window.showOpenFilePicker(pickerOpts);\n\n  // get file contents\n  const fileData = await fileHandle.getFile();\n} Accessing directories The following example returns a directory handle with the specified name. If the directory does not exist, it is created. js const dirName = \"directoryToGetName\";\n\n// assuming we have a directory handle: 'currentDirHandle'\nconst subDir = await currentDirHandle.getDirectoryHandle(dirName, {\n  create: true,\n}); The following asynchronous function uses resolve() to find the path to a chosen file, relative to a specified directory handle. js async function returnPathDirectories(directoryHandle) {\n  // Get a file handle by showing a file picker:\n  const [handle] = await self.showOpenFilePicker();\n  if (!handle) {\n    // User cancelled, or otherwise failed to open a file.\n    return;\n  }\n\n  // Check if handle exists inside our directory handle\n  const relativePaths = await directoryHandle.resolve(handle);\n\n  if (relativePaths === null) {\n    // Not inside directory handle\n  } else {\n    // relativePaths is an array of names, giving the relative path\n\n    for (const name of relativePaths) {\n      // log each entry\n      console.log(name);\n    }\n  }\n} Writing to files The following asynchronous function opens the save file picker, which returns a FileSystemFileHandle once a file is selected. A writable stream is then created using the FileSystemFileHandle.createWritable() method. A user defined Blob is then written to the stream which is subsequently closed. js async function saveFile() {\n  // create a new handle\n  const newHandle = await window.showSaveFilePicker();\n\n  // create a FileSystemWritableFileStream to write to\n  const writableStream = await newHandle.createWritable();\n\n  // write our file\n  await writableStream.write(imgBlob);\n\n  // close the file and write the contents to disk.\n  await writableStream.close();\n} The following show different examples of options that can be passed into the write() method. js // just pass in the data (no options)\nwritableStream.write(data);\n\n// writes the data to the stream from the determined position\nwritableStream.write({ type: \"write\", position, data });\n\n// updates the current file cursor offset to the position specified\nwritableStream.write({ type: \"seek\", position });\n\n// resizes the file to be size bytes long\nwritableStream.write({ type: \"truncate\", size }); Synchronously reading and writing files in OPFS This example synchronously reads and writes a file to the origin private file system . The following asynchronous event handler function is contained inside a Web Worker. On receiving a message from the main thread it: Creates a synchronous file access handle. Gets the size of the file and creates an ArrayBuffer to contain it. Reads the file contents into the buffer. Encodes the message and writes it to the end of the file. Persists the changes to disk and closes the access handle. js onmessage = async (e) => {\n  // retrieve message sent to work from main script\n  const message = e.data;\n\n  // Get handle to draft file in OPFS\n  const root = await navigator.storage.getDirectory();\n  const draftHandle = await root.getFileHandle(\"draft.txt\", { create: true });\n  // Get sync access handle\n  const accessHandle = await draftHandle.createSyncAccessHandle();\n\n  // Get size of the file.\n  const fileSize = accessHandle.getSize();\n  // Read file content to a buffer.\n  const buffer = new DataView(new ArrayBuffer(fileSize));\n  const readBuffer = accessHandle.read(buffer, { at: 0 });\n\n  // Write the message to the end of the file.\n  const encoder = new TextEncoder();\n  const encodedMessage = encoder.encode(message);\n  const writeBuffer = accessHandle.write(encodedMessage, { at: readBuffer });\n\n  // Persist changes to disk.\n  accessHandle.flush();\n\n  // Always close FileSystemSyncAccessHandle if done.\n  accessHandle.close();\n}; Note: In earlier versions of the spec, close() , flush() , getSize() , and truncate() were unergonomically specified as asynchronous methods. This has now been amended , but some browsers still support the asynchronous versions. Specifications Specification File System > File System Access > Browser compatibility > api.FileSystemHandle api.FileSystemFileHandle api.FileSystemDirectoryHandle api.FileSystemWritableFileStream api.FileSystemSyncAccessHandle See also The File System Access API: simplifying access to local files The origin private file system Help improve MDN Learn how to contribute This page was last modified on \u2068Oct 20, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content"
    }
  },
  "metadata": {
    "jsonld": [],
    "microdata": [],
    "opengraph": {},
    "twitter": {
      "card": "summary_large_image",
      "creator": "MozDevNet"
    }
  },
  "timestamp": "2025-12-04T13:38:15.083333"
}