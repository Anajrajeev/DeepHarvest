{
  "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes",
  "content": {
    "text": {
      "title": "Using classes - JavaScript | MDN",
      "text": "Using classes - JavaScript | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all\u2026 HTML guides Responsive images HTML cheatsheet Date & time formats See all\u2026 Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values See all\u2026 CSS guides Box model Animations Flexbox Colors See all\u2026 Layout cookbook Column layouts Centering an element Card component See all\u2026 JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all\u2026 JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all\u2026 Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all\u2026 Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all\u2026 Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started modules Core modules MDN Curriculum Learn HTML Structuring content with HTML module Learn CSS CSS styling basics module CSS layout module Learn JavaScript Dynamic scripting with JavaScript module Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Web JavaScript Guide Using classes Using classes Previous Next JavaScript is a prototype-based language \u2014 an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes. In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism \u2014 all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors \u2014 you use the new operator with a constructor function to create a new object. We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide. This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects. In this article Overview of classes Declaring a class Constructor Instance methods Private fields Accessor fields Public fields Static properties Extends and inheritance Why classes? Overview of classes If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you : js const bigDay = new Date(2019, 6, 19);\nconsole.log(bigDay.toLocaleDateString());\nif (bigDay.getTime() < Date.now()) {\n  console.log(\"Once upon a time...\");\n} On the first line, we created an instance of the class Date , and called it bigDay . On the second line, we called a method toLocaleDateString() on the bigDay instance, which returns a string. Then, we compared two numbers: one returned from the getTime() method, the other directly called from the Date class itself , as Date.now() . Date is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do: Classes create objects through the new operator. Each object has some properties (data or method) added by the class. The class stores some properties (data or method) itself, which are usually used to interact with instances. These correspond to the three key features of classes: Constructor; Instance methods and instance fields; Static methods and static fields. Declaring a class Classes are usually created with class declarations . js class MyClass {\n  // class body...\n} Within a class body, there are a range of features available. js class MyClass {\n  // Constructor\n  constructor() {\n    // Constructor body\n  }\n  // Instance field\n  myField = \"foo\";\n  // Instance method\n  myMethod() {\n    // myMethod body\n  }\n  // Static field\n  static myStaticField = \"bar\";\n  // Static method\n  static myStaticMethod() {\n    // myStaticMethod body\n  }\n  // Static block\n  static {\n    // Static initialization code\n  }\n  // Fields, methods, static fields, and static methods all have\n  // \"private\" forms\n  #myPrivateField = \"bar\";\n} If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors: js function MyClass() {\n  this.myField = \"foo\";\n  // Constructor body\n}\nMyClass.myStaticField = \"bar\";\nMyClass.myStaticMethod = function () {\n  // myStaticMethod body\n};\nMyClass.prototype.myMethod = function () {\n  // myMethod body\n};\n\n(function () {\n  // Static initialization code\n})(); Note: Private fields and methods are new features in classes with no trivial equivalent in function constructors. Constructing a class After a class has been declared, you can create instances of it using the new operator. js const myInstance = new MyClass();\nconsole.log(myInstance.myField); // 'foo'\nmyInstance.myMethod(); Typical function constructors can both be constructed with new and called without new . However, attempting to \"call\" a class without new will result in an error. js const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new' Class declaration hoisting Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared. js new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization\n\nclass MyClass {} This behavior is similar to variables declared with let and const . Class expressions Similar to functions, class declarations also have their expression counterparts. js const MyClass = class {\n  // Class body...\n}; Class expressions can have names as well. The expression's name is only visible to the class's body. js const MyClass = class MyClassLongerName {\n  // Class body. Here MyClass and MyClassLongerName point to the same class.\n};\nnew MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined Constructor Perhaps the most important job of a class is to act as a \"factory\" for objects. For example, when we use the Date constructor, we expect it to give a new object which represents the date data we passed in \u2014 which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor . As an example, we would create a class called Color , which represents a specific color. Users create colors through passing in an RGB triplet. js class Color {\n  constructor(r, g, b) {\n    // Assign the RGB values as a property of `this`.\n    this.values = [r, g, b];\n  }\n} Open your browser's devtools, paste the above code into the console, and then create an instance: js const red = new Color(255, 0, 0);\nconsole.log(red); You should see some output like this: Object { values: (3) [\u2026] }\n  values: Array(3) [ 255, 0, 0 ] You have successfully created a Color instance, and the instance has a values property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following: js function createColor(r, g, b) {\n  return {\n    values: [r, g, b],\n  };\n} The constructor's syntax is exactly the same as a normal function \u2014 which means you can use other syntaxes, like rest parameters : js class Color {\n  constructor(...values) {\n    this.values = values;\n  }\n}\n\nconst red = new Color(255, 0, 0);\n// Creates an instance with the same shape as above. Each time you call new , a different instance is created. js const red = new Color(255, 0, 0);\nconst anotherRed = new Color(255, 0, 0);\nconsole.log(red === anotherRed); // false Within a class constructor, the value of this points to the newly created instance. You can assign properties to it, or read existing properties (especially methods \u2014 which we will cover next). The this value will be automatically returned as the result of new . You are advised to not return any value from the constructor \u2014 because if you return a non-primitive value, it will become the value of the new expression, and the value of this is dropped. (You can read more about what new does in its description .) js class MyClass {\n  constructor() {\n    this.myField = \"foo\";\n    return {};\n  }\n}\n\nconsole.log(new MyClass().myField); // undefined Instance methods If a class only has a constructor, it is not much different from a createX factory function which just creates plain objects. However, the power of classes is that they can be used as \"templates\" which automatically assign methods to instances. For example, for Date instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the setX counterparts like setFullYear . For our own Color class, we can add a method called getRed which returns the red value of the color. js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  getRed() {\n    return this.values[0];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconsole.log(red.getRed()); // 255 Without methods, you may be tempted to define the function within the constructor: js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n    this.getRed = function () {\n      return this.values[0];\n    };\n  }\n} This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing! js console.log(new Color().getRed === new Color().getRed); // false In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. If you are curious where this method is stored in \u2014 it's defined on the prototype of all instances, or Color.prototype , which is explained in more detail in Inheritance and the prototype chain . Similarly, we can create a new method called setRed , which sets the red value of the color. js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  getRed() {\n    return this.values[0];\n  }\n  setRed(value) {\n    this.values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.setRed(0);\nconsole.log(red.getRed()); // 0; of course, it should be called \"black\" at this stage! Private fields You might be wondering: why do we want to go to the trouble of using getRed and setRed methods, when we can directly access the values array on the instance? js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.values[0] = 0;\nconsole.log(red.values[0]); // 0 There is a philosophy in object-oriented programming called \"encapsulation\". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead: js class Color {\n  constructor(r, g, b) {\n    // values is now an HSL array!\n    this.values = rgbToHSL([r, g, b]);\n  }\n  getRed() {\n    return hslToRGB(this.values)[0];\n  }\n  setRed(value) {\n    const rgb = hslToRGB(this.values);\n    rgb[0] = value;\n    this.values = rgbToHSL(rgb);\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconsole.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0 The user assumption that values means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some \"harmless refactors\". In classes, this is done through private fields . A private field is an identifier prefixed with # (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property. js class Color {\n  // Declare: every Color instance has a private field called #values.\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  getRed() {\n    return this.#values[0];\n  }\n  setRed(value) {\n    this.#values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconsole.log(red.getRed()); // 255 Accessing private fields outside the class is an early syntax error. The language can guard against this because #privateField is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code. js console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class Note: Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction. Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same. After we've made the values field private, we can add some more logic in the getRed and setRed methods, instead of making them simple pass-through methods. For example, we can add a check in setRed to see if it's a valid R value: js class Color {\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  getRed() {\n    return this.#values[0];\n  }\n  setRed(value) {\n    if (value < 0 || value > 255) {\n      throw new RangeError(\"Invalid R value\");\n    }\n    this.#values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.setRed(1000); // RangeError: Invalid R value If we leave the values property exposed, our users can easily circumvent that check by assigning to values[0] directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream. A class method can read the private fields of other instances, as long as they belong to the same class. js class Color {\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  redDifference(anotherColor) {\n    // #values doesn't necessarily need to be accessed from this:\n    // you can access private fields of other instances belonging\n    // to the same class.\n    return this.#values[0] - anotherColor.#values[0];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconst crimson = new Color(220, 20, 60);\nred.redDifference(crimson); // 35 However, if anotherColor is not a Color instance, #values won't exist. (Even if another class has an identically named #values private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning undefined like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using try / catch to handle the error, you can use the in operator. js class Color {\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  redDifference(anotherColor) {\n    if (!(#values in anotherColor)) {\n      throw new TypeError(\"Color instance expected\");\n    }\n    return this.#values[0] - anotherColor.#values[0];\n  }\n} Note: Keep in mind that the # is a special identifier syntax, and you can't use the field name as if it's a string. \"#values\" in anotherColor would look for a property name literally called \"#values\" , instead of a private field. There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors. js class BadIdeas {\n  #firstName;\n  #firstName; // syntax error occurs here\n  #lastName;\n  constructor() {\n    delete this.#lastName; // also a syntax error\n  }\n} Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call. For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it. js class Counter extends HTMLElement {\n  #xValue = 0;\n  constructor() {\n    super();\n    this.onclick = this.#clicked.bind(this);\n  }\n  get #x() {\n    return this.#xValue;\n  }\n  set #x(value) {\n    this.#xValue = value;\n    window.requestAnimationFrame(this.#render.bind(this));\n  }\n  #clicked() {\n    this.#x++;\n  }\n  #render() {\n    this.textContent = this.#x.toString();\n  }\n  connectedCallback() {\n    this.#render();\n  }\n}\n\ncustomElements.define(\"num-counter\", Counter); In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of Counter . Accessor fields color.getRed() and color.setRed() allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an \"actual property\". js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  get red() {\n    return this.values[0];\n  }\n  set red(value) {\n    this.values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.red = 0;\nconsole.log(red.red); // 0 It looks as if the object has a property called red \u2014 but actually, no such property exists on the instance! There are only two methods, but they are prefixed with get and set , which allows them to be manipulated as if they were properties. If a field only has a getter but no setter, it will be effectively read-only. js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  get red() {\n    return this.values[0];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.red = 0;\nconsole.log(red.red); // 255 In strict mode , the red.red = 0 line will throw a type error: \"Cannot set property red of #<Color> which has only a getter\". In non-strict mode, the assignment is silently ignored. Public fields Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters. js class MyClass {\n  luckyNumber = Math.random();\n}\nconsole.log(new MyClass().luckyNumber); // 0.5\nconsole.log(new MyClass().luckyNumber); // 0.3 Public fields are almost equivalent to assigning a property to this . For example, the above example can also be converted to: js class MyClass {\n  constructor() {\n    this.luckyNumber = Math.random();\n  }\n} Static properties With the Date example, we have also encountered the Date.now() method, which returns the current date. This method does not belong to any date instance \u2014 it belongs to the class itself. However, it's put on the Date class instead of being exposed as a global DateNow() function, because it's mostly useful when dealing with date instances. Note: Prefixing utility methods with what they deal with is called \"namespacing\" and is considered a good practice. For example, in addition to the older, unprefixed parseInt() method, JavaScript also later added the prefixed Number.parseInt() method to indicate that it's for dealing with numbers. Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include: Static methods Static fields Static getters and setters Everything also has private counterparts. For example, for our Color class, we can create a static method that checks whether a given triplet is a valid RGB value: js class Color {\n  static isValid(r, g, b) {\n    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;\n  }\n}\n\nColor.isValid(255, 0, 0); // true\nColor.isValid(1000, 0, 0); // false Static properties are very similar to their instance counterparts, except that: They are all prefixed with static , and They are not accessible from instances. js console.log(new Color(0, 0, 0).isValid); // undefined There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded. js class MyClass {\n  static {\n    MyClass.myStaticProperty = \"foo\";\n  }\n}\n\nconsole.log(MyClass.myStaticProperty); // 'foo' Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements. Extends and inheritance A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can \"borrow\" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic. For example, suppose our Color class now needs to support transparency. We may be tempted to add a new field that indicates its transparency: js class Color {\n  #values;\n  constructor(r, g, b, a = 1) {\n    this.#values = [r, g, b, a];\n  }\n  get alpha() {\n    return this.#values[3];\n  }\n  set alpha(value) {\n    if (value < 0 || value > 1) {\n      throw new RangeError(\"Alpha value must be between 0 and 1\");\n    }\n    this.#values[3] = value;\n  }\n} However, this means every instance \u2014 even the vast majority which aren't transparent (those with an alpha value of 1) \u2014 will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our Color class will become very bloated and hard to maintain. Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an extends clause, which indicates the class it extends from. js class ColorWithAlpha extends Color {\n  #alpha;\n  constructor(r, g, b, a) {\n    super(r, g, b);\n    this.#alpha = a;\n  }\n  get alpha() {\n    return this.#alpha;\n  }\n  set alpha(value) {\n    if (value < 0 || value > 1) {\n      throw new RangeError(\"Alpha value must be between 0 and 1\");\n    }\n    this.#alpha = value;\n  }\n} There are a few things that have immediately come to attention. First is that in the constructor, we are calling super(r, g, b) . It is a language requirement to call super() before accessing this . The super() call calls the parent class's constructor to initialize this \u2014 here it's roughly equivalent to this = new Color(r, g, b) . You can have code before super() , but you cannot access this before super() \u2014 the language prevents you from accessing the uninitialized this . After the parent class is done with modifying this , the derived class can do its own logic. Here we added a private field called #alpha , and also provided a pair of getter/setters to interact with them. A derived class inherits all methods from its parent. For example, consider the get red() accessor we added to the Color in the Accessor fields section\u2014even though we haven't declared one in ColorWithAlpha , we can still access red because this behavior is specified by the parent class: js const color = new ColorWithAlpha(255, 0, 0, 0.5);\nconsole.log(color.red); // 255 Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the Object class, which defines some basic methods like toString() . However, the base toString() method is notoriously useless, because it prints [object Object] in most cases: js console.log(red.toString()); // [object Object] Instead, our class can override it to print the color's RGB values: js class Color {\n  #values;\n  // \u2026\n  toString() {\n    return this.#values.join(\", \");\n  }\n}\n\nconsole.log(new Color(255, 0, 0).toString()); // '255, 0, 0' Within derived classes, you can access the parent class's methods by using super . This allows you to build enhancement methods and avoid code duplication. js class ColorWithAlpha extends Color {\n  #alpha;\n  // \u2026\n  toString() {\n    // Call the parent class's toString() and build on the return value\n    return `${super.toString()}, ${this.#alpha}`;\n  }\n}\n\nconsole.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5' When you use extends , the static methods inherit from each other as well, so you can also override or enhance them. js class ColorWithAlpha extends Color {\n  // \u2026\n  static isValid(r, g, b, a) {\n    // Call the parent class's isValid() and build on the return value\n    return super.isValid(r, g, b) && a >= 0 && a <= 1;\n  }\n}\n\nconsole.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false Derived classes don't have access to the parent class's private fields \u2014 this is another key aspect to JavaScript private fields being \"hard private\". Private fields are scoped to the class body itself and do not grant access to any outside code. js class ColorWithAlpha extends Color {\n  log() {\n    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class\n  }\n} A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins . Instances of derived classes are also instances of the base class. js const color = new ColorWithAlpha(255, 0, 0, 0.5);\nconsole.log(color instanceof Color); // true\nconsole.log(color instanceof ColorWithAlpha); // true Why classes? The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends. Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result. For example, one thing that makes Date objects infamous is that they're mutable . js function incrementDay(date) {\n  return date.setDate(date.getDate() + 1);\n}\nconst date = new Date(); // 2019-06-19\nconst newDay = incrementDay(date);\nconsole.log(newDay); // 2019-06-20\n// The old date is modified as well!?\nconsole.log(date); // 2019-06-20 Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with \u2014 because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program. In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns. However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient. On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the Color class, we may need to create a dozen of utility functions: js function isRed(color) {\n  return color.red === 255;\n}\nfunction isValidColor(color) {\n  return (\n    color.red >= 0 &&\n    color.red <= 255 &&\n    color.green >= 0 &&\n    color.green <= 255 &&\n    color.blue >= 0 &&\n    color.blue <= 255\n  );\n}\n// \u2026 But with classes, we can congregate them all under the Color namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API. In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples: The Map and Set classes store a collection of elements and allow you to access them by key using get() , set() , has() , etc. The Date class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components. The Error class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like TypeError and ReferenceError that extend Error . In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with instanceof . JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion. Previous Next Help improve MDN Learn how to contribute This page was last modified on \u2068Nov 24, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content JavaScript Tutorials and guides JavaScript Guide Introduction Grammar and types Control flow and error handling Loops and iteration Functions Expressions and operators Numbers and strings Representing dates & times Regular expressions Indexed collections Keyed collections Working with objects Using classes Using promises JavaScript typed arrays Iterators and generators Resource management Internationalization JavaScript modules Intermediate Language overview JavaScript data structures Equality comparisons and sameness Enumerability and ownership of properties Closures Advanced Inheritance and the prototype chain Meta programming Memory Management References Built-in objects AggregateError Array ArrayBuffer AsyncDisposableStack AsyncFunction AsyncGenerator AsyncGeneratorFunction AsyncIterator Atomics BigInt BigInt64Array BigUint64Array Boolean DataView Date decodeURI() decodeURIComponent() DisposableStack encodeURI() encodeURIComponent() Error escape() Deprecated eval() EvalError FinalizationRegistry Float16Array Float32Array Float64Array Function Generator GeneratorFunction globalThis Infinity Int8Array Int16Array Int32Array InternalError Non-standard Intl isFinite() isNaN() Iterator JSON Map Math NaN Number Object parseFloat() parseInt() Promise Proxy RangeError ReferenceError Reflect RegExp Set SharedArrayBuffer String SuppressedError Symbol SyntaxError Temporal Experimental TypedArray TypeError Uint8Array Uint8ClampedArray Uint16Array Uint32Array undefined unescape() Deprecated URIError WeakMap WeakRef WeakSet Expressions & operators Addition (+) Addition assignment (+=) Assignment (=) async function expression async function* expression await Bitwise AND (&) Bitwise AND assignment (&=) Bitwise NOT (~) Bitwise OR (|) Bitwise OR assignment (|=) Bitwise XOR (^) Bitwise XOR assignment (^=) class expression Comma operator (,) Conditional (ternary) operator Decrement (--) delete Destructuring Division (/) Division assignment (/=) Equality (==) Exponentiation (**) Exponentiation assignment (**=) function expression function* expression Greater than (>) Greater than or equal (>=) Grouping operator ( ) import.meta import.meta.resolve() import() in Increment (++) Inequality (!=) instanceof Left shift (<<) Left shift assignment (<<=) Less than (<) Less than or equal (<=) Logical AND (&&) Logical AND assignment (&&=) Logical NOT (!) Logical OR (||) Logical OR assignment (||=) Multiplication (*) Multiplication assignment (*=) new new.target null Nullish coalescing assignment (??=) Nullish coalescing operator (??) Object initializer Operator precedence Optional chaining (?.) Property accessors Remainder (%) Remainder assignment (%=) Right shift (>>) Right shift assignment (>>=) Spread syntax (...) Strict equality (===) Strict inequality (!==) Subtraction (-) Subtraction assignment (-=) super this typeof Unary negation (-) Unary plus (+) Unsigned right shift (>>>) Unsigned right shift assignment (>>>=) void operator yield yield* Statements & declarations async function async function* await using Block statement break class const continue debugger do...while Empty statement export Expression statement for for await...of for...in for...of function function* if...else import Import attributes Labeled statement let return switch throw try...catch using var while with Deprecated Functions Arrow function expressions Default parameters get Method definitions Rest parameters set The arguments object [Symbol.iterator]() callee Deprecated length Classes constructor extends Private elements Public class fields static Static initialization blocks Regular expressions Backreference: \\1, \\2 Capturing group: (...) Character class escape: \\d, \\D, \\w, \\W, \\s, \\S Character class: [...], [^...] Character escape: \\n, \\u{...} Disjunction: | Input boundary assertion: ^, $ Literal character: a, b Lookahead assertion: (?=...), (?!...) Lookbehind assertion: (?<=...), (?<!...) Modifier: (?ims-ims:...) Named backreference: \\k<name> Named capturing group: (?<name>...) Non-capturing group: (?:...) Quantifier: *, +, ?, {n}, {n,}, {n,m} Unicode character class escape: \\p{...}, \\P{...} Wildcard: . Word boundary assertion: \\b, \\B Errors AggregateError: No Promise in Promise.any was resolved Error: Permission denied to access property \"x\" InternalError: too much recursion RangeError: argument is not a valid code point RangeError: BigInt division by zero RangeError: BigInt negative exponent RangeError: form must be one of 'NFC', 'NFD', 'NFKC', or 'NFKD' RangeError: invalid array length RangeError: invalid date RangeError: precision is out of range RangeError: radix must be an integer RangeError: repeat count must be less than infinity RangeError: repeat count must be non-negative RangeError: x can't be converted to BigInt because it isn't an integer ReferenceError: \"x\" is not defined ReferenceError: assignment to undeclared variable \"x\" ReferenceError: can't access lexical declaration 'X' before initialization ReferenceError: must call super constructor before using 'this' in derived class constructor ReferenceError: super() called twice in derived class constructor SyntaxError: 'arguments'/'eval' can't be defined or assigned to in strict mode code SyntaxError: \"0\"-prefixed octal literals are deprecated SyntaxError: \"use strict\" not allowed in function with non-simple parameters SyntaxError: \"x\" is a reserved identifier SyntaxError: \\ at end of pattern SyntaxError: a declaration in the head of a for-of loop can't have an initializer SyntaxError: applying the 'delete' operator to an unqualified name is deprecated SyntaxError: arguments is not valid in fields SyntaxError: await is only valid in async functions, async generators and modules SyntaxError: await/yield expression can't be used in parameter SyntaxError: cannot use `??` unparenthesized within `||` and `&&` expressions SyntaxError: character class escape cannot be used in class range in regular expression SyntaxError: continue must be inside loop SyntaxError: duplicate capture group name in regular expression SyntaxError: duplicate formal argument x SyntaxError: for-in loop head declarations may not have initializers SyntaxError: function statement requires a name SyntaxError: functions cannot be labelled SyntaxError: getter and setter for private name #x should either be both static or non-static SyntaxError: getter functions must have no arguments SyntaxError: identifier starts immediately after numeric literal SyntaxError: illegal character SyntaxError: import declarations may only appear at top level of a module SyntaxError: incomplete quantifier in regular expression SyntaxError: invalid assignment left-hand side SyntaxError: invalid BigInt syntax SyntaxError: invalid capture group name in regular expression SyntaxError: invalid character in class in regular expression SyntaxError: invalid class set operation in regular expression SyntaxError: invalid decimal escape in regular expression SyntaxError: invalid identity escape in regular expression SyntaxError: invalid named capture reference in regular expression SyntaxError: invalid property name in regular expression SyntaxError: invalid range in character class SyntaxError: invalid regexp group SyntaxError: invalid regular expression flag \"x\" SyntaxError: invalid unicode escape in regular expression SyntaxError: JSON.parse: bad parsing SyntaxError: label not found SyntaxError: missing : after property id SyntaxError: missing ) after argument list SyntaxError: missing ) after condition SyntaxError: missing ] after element list SyntaxError: missing } after function body SyntaxError: missing } after property list SyntaxError: missing = in const declaration SyntaxError: missing formal parameter SyntaxError: missing name after . operator SyntaxError: missing variable name SyntaxError: negated character class with strings in regular expression SyntaxError: new keyword cannot be used with an optional chain SyntaxError: nothing to repeat SyntaxError: numbers out of order in {} quantifier. SyntaxError: octal escape sequences can't be used in untagged template literals or in strict mode code SyntaxError: parameter after rest parameter SyntaxError: private fields can't be deleted SyntaxError: property name __proto__ appears more than once in object literal SyntaxError: raw bracket is not allowed in regular expression with unicode flag SyntaxError: redeclaration of formal parameter \"x\" SyntaxError: reference to undeclared private field or method #x SyntaxError: rest parameter may not have a default SyntaxError: return not in function SyntaxError: setter functions must have one argument SyntaxError: string literal contains an unescaped line break SyntaxError: super() is only valid in derived class constructors SyntaxError: tagged template cannot be used with optional chain SyntaxError: Unexpected '#' used outside of class body SyntaxError: Unexpected token SyntaxError: unlabeled break must be inside loop or switch SyntaxError: unparenthesized unary expression can't appear on the left-hand side of '**' SyntaxError: use of super property/member accesses only valid within methods or eval code within methods SyntaxError: Using //@ to indicate sourceURL pragmas is deprecated. Use //# instead TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed TypeError: 'x' is not iterable TypeError: \"x\" is (not) \"y\" TypeError: \"x\" is not a constructor TypeError: \"x\" is not a function TypeError: \"x\" is not a non-null object TypeError: \"x\" is read-only TypeError: already executing generator TypeError: BigInt value can't be serialized in JSON TypeError: calling a builtin X constructor without new is forbidden TypeError: can't access/set private field or method: object is not the right class TypeError: can't assign to property \"x\" on \"y\": not an object TypeError: can't convert BigInt to number TypeError: can't convert x to BigInt TypeError: can't define property \"x\": \"obj\" is not extensible TypeError: can't delete non-configurable array element TypeError: can't redefine non-configurable property \"x\" TypeError: can't set prototype of this object TypeError: can't set prototype: it would cause a prototype chain cycle TypeError: cannot use 'in' operator to search for 'x' in 'y' TypeError: class constructors must be invoked with 'new' TypeError: cyclic object value TypeError: derived class constructor returned invalid value x TypeError: getting private setter-only property TypeError: Initializing an object twice is an error with private fields/methods TypeError: invalid 'instanceof' operand 'x' TypeError: invalid Array.prototype.sort argument TypeError: invalid assignment to const \"x\" TypeError: Iterator/AsyncIterator constructor can't be used directly TypeError: matchAll/replaceAll must be called with a global RegExp TypeError: More arguments needed TypeError: null/undefined has no properties TypeError: property \"x\" is non-configurable and can't be deleted TypeError: Reduce of empty array with no initial value TypeError: setting getter-only property \"x\" TypeError: WeakSet key/WeakMap value 'x' must be an object or an unregistered symbol TypeError: X.prototype.y called on incompatible type URIError: malformed URI sequence Warning: -file- is being assigned a //# sourceMappingURL, but already has one Warning: unreachable code after return statement Misc JavaScript technologies overview Execution model Lexical grammar Iteration protocols Strict mode Template literals Trailing commas Deprecated features Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation\u2019s not-for-profit parent, the Mozilla Foundation . Portions of this content are \u00a91998\u2013\u20682025\u2069 by individual mozilla.org contributors. Content available under a Creative Commons license .",
      "meta": {
        "viewport": "width=device-width, initial-scale=1.0",
        "description": "JavaScript is a prototype-based language \u2014 an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.",
        "og:url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_classes",
        "og:title": "Using classes - JavaScript | MDN",
        "og:locale": "en_US",
        "og:description": "JavaScript is a prototype-based language \u2014 an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.",
        "og:image": "https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png",
        "og:image:type": "image/png",
        "og:image:height": "1080",
        "og:image:width": "1920",
        "og:image:alt": "The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background.",
        "og:site_name": "MDN Web Docs",
        "twitter:card": "summary_large_image",
        "twitter:creator": "MozDevNet",
        "position": "4"
      },
      "keywords": [],
      "language": "en",
      "word_count": 6493,
      "description": "JavaScript is a prototype-based language \u2014 an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes, the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes.",
      "clean_text": "Using classes Previous Next JavaScript is a prototype-based language \u2014 an object's behaviors are specified by its own properties and its prototype's properties. However, with the addition of classes , the creation of hierarchies of objects and the inheritance of properties and their values are much more in line with other object-oriented languages such as Java. In this section, we will demonstrate how objects can be created from classes. In many other languages, classes , or constructors, are clearly distinguished from objects , or instances. In JavaScript, classes are mainly an abstraction over the existing prototypical inheritance mechanism \u2014 all patterns are convertible to prototype-based inheritance. Classes themselves are normal JavaScript values as well, and have their own prototype chains. In fact, most plain JavaScript functions can be used as constructors \u2014 you use the new operator with a constructor function to create a new object. We will be playing with the well-abstracted class model in this tutorial, and discuss what semantics classes offer. If you want to dive deep into the underlying prototype system, you can read the Inheritance and the prototype chain guide. This chapter assumes that you are already somewhat familiar with JavaScript and that you have used ordinary objects. In this article Overview of classes Declaring a class Constructor Instance methods Private fields Accessor fields Public fields Static properties Extends and inheritance Why classes? Overview of classes If you have some hands-on experience with JavaScript, or have followed along with the guide, you probably have already used classes, even if you haven't created one. For example, this may seem familiar to you : js const bigDay = new Date(2019, 6, 19);\nconsole.log(bigDay.toLocaleDateString());\nif (bigDay.getTime() < Date.now()) {\n  console.log(\"Once upon a time...\");\n} On the first line, we created an instance of the class Date , and called it bigDay . On the second line, we called a method toLocaleDateString() on the bigDay instance, which returns a string. Then, we compared two numbers: one returned from the getTime() method, the other directly called from the Date class itself , as Date.now() . Date is a built-in class of JavaScript. From this example, we can get some basic ideas of what classes do: Classes create objects through the new operator. Each object has some properties (data or method) added by the class. The class stores some properties (data or method) itself, which are usually used to interact with instances. These correspond to the three key features of classes: Constructor; Instance methods and instance fields; Static methods and static fields. Declaring a class Classes are usually created with class declarations . js class MyClass {\n  // class body...\n} Within a class body, there are a range of features available. js class MyClass {\n  // Constructor\n  constructor() {\n    // Constructor body\n  }\n  // Instance field\n  myField = \"foo\";\n  // Instance method\n  myMethod() {\n    // myMethod body\n  }\n  // Static field\n  static myStaticField = \"bar\";\n  // Static method\n  static myStaticMethod() {\n    // myStaticMethod body\n  }\n  // Static block\n  static {\n    // Static initialization code\n  }\n  // Fields, methods, static fields, and static methods all have\n  // \"private\" forms\n  #myPrivateField = \"bar\";\n} If you came from a pre-ES6 world, you may be more familiar with using functions as constructors. The pattern above would roughly translate to the following with function constructors: js function MyClass() {\n  this.myField = \"foo\";\n  // Constructor body\n}\nMyClass.myStaticField = \"bar\";\nMyClass.myStaticMethod = function () {\n  // myStaticMethod body\n};\nMyClass.prototype.myMethod = function () {\n  // myMethod body\n};\n\n(function () {\n  // Static initialization code\n})(); Note: Private fields and methods are new features in classes with no trivial equivalent in function constructors. Constructing a class After a class has been declared, you can create instances of it using the new operator. js const myInstance = new MyClass();\nconsole.log(myInstance.myField); // 'foo'\nmyInstance.myMethod(); Typical function constructors can both be constructed with new and called without new . However, attempting to \"call\" a class without new will result in an error. js const myInstance = MyClass(); // TypeError: Class constructor MyClass cannot be invoked without 'new' Class declaration hoisting Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared. js new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization\n\nclass MyClass {} This behavior is similar to variables declared with let and const . Class expressions Similar to functions, class declarations also have their expression counterparts. js const MyClass = class {\n  // Class body...\n}; Class expressions can have names as well. The expression's name is only visible to the class's body. js const MyClass = class MyClassLongerName {\n  // Class body. Here MyClass and MyClassLongerName point to the same class.\n};\nnew MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined Constructor Perhaps the most important job of a class is to act as a \"factory\" for objects. For example, when we use the Date constructor, we expect it to give a new object which represents the date data we passed in \u2014 which we can then manipulate with other methods the instance exposes. In classes, the instance creation is done by the constructor . As an example, we would create a class called Color , which represents a specific color. Users create colors through passing in an RGB triplet. js class Color {\n  constructor(r, g, b) {\n    // Assign the RGB values as a property of `this`.\n    this.values = [r, g, b];\n  }\n} Open your browser's devtools, paste the above code into the console, and then create an instance: js const red = new Color(255, 0, 0);\nconsole.log(red); You should see some output like this: Object { values: (3) [\u2026] }\n  values: Array(3) [ 255, 0, 0 ] You have successfully created a Color instance, and the instance has a values property, which is an array of the RGB values you passed in. That is pretty much equivalent to the following: js function createColor(r, g, b) {\n  return {\n    values: [r, g, b],\n  };\n} The constructor's syntax is exactly the same as a normal function \u2014 which means you can use other syntaxes, like rest parameters : js class Color {\n  constructor(...values) {\n    this.values = values;\n  }\n}\n\nconst red = new Color(255, 0, 0);\n// Creates an instance with the same shape as above. Each time you call new , a different instance is created. js const red = new Color(255, 0, 0);\nconst anotherRed = new Color(255, 0, 0);\nconsole.log(red === anotherRed); // false Within a class constructor, the value of this points to the newly created instance. You can assign properties to it, or read existing properties (especially methods \u2014 which we will cover next). The this value will be automatically returned as the result of new . You are advised to not return any value from the constructor \u2014 because if you return a non-primitive value, it will become the value of the new expression, and the value of this is dropped. (You can read more about what new does in its description .) js class MyClass {\n  constructor() {\n    this.myField = \"foo\";\n    return {};\n  }\n}\n\nconsole.log(new MyClass().myField); // undefined Instance methods If a class only has a constructor, it is not much different from a createX factory function which just creates plain objects. However, the power of classes is that they can be used as \"templates\" which automatically assign methods to instances. For example, for Date instances, you can use a range of methods to get different information from a single date value, such as the year , month , day of the week , etc. You can also set those values through the setX counterparts like setFullYear . For our own Color class, we can add a method called getRed which returns the red value of the color. js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  getRed() {\n    return this.values[0];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconsole.log(red.getRed()); // 255 Without methods, you may be tempted to define the function within the constructor: js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n    this.getRed = function () {\n      return this.values[0];\n    };\n  }\n} This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing! js console.log(new Color().getRed === new Color().getRed); // false In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. If you are curious where this method is stored in \u2014 it's defined on the prototype of all instances, or Color.prototype , which is explained in more detail in Inheritance and the prototype chain . Similarly, we can create a new method called setRed , which sets the red value of the color. js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  getRed() {\n    return this.values[0];\n  }\n  setRed(value) {\n    this.values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.setRed(0);\nconsole.log(red.getRed()); // 0; of course, it should be called \"black\" at this stage! Private fields You might be wondering: why do we want to go to the trouble of using getRed and setRed methods, when we can directly access the values array on the instance? js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.values[0] = 0;\nconsole.log(red.values[0]); // 0 There is a philosophy in object-oriented programming called \"encapsulation\". This means you should not access the underlying implementation of an object, but instead use well-abstracted methods to interact with it. For example, if we suddenly decided to represent colors as HSL instead: js class Color {\n  constructor(r, g, b) {\n    // values is now an HSL array!\n    this.values = rgbToHSL([r, g, b]);\n  }\n  getRed() {\n    return hslToRGB(this.values)[0];\n  }\n  setRed(value) {\n    const rgb = hslToRGB(this.values);\n    rgb[0] = value;\n    this.values = rgbToHSL(rgb);\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconsole.log(red.values[0]); // 0; It's not 255 anymore, because the H value for pure red is 0 The user assumption that values means the RGB value suddenly collapses, and it may cause their logic to break. So, if you are an implementor of a class, you would want to hide the internal data structure of your instance from your user, both to keep the API clean and to prevent the user's code from breaking when you do some \"harmless refactors\". In classes, this is done through private fields . A private field is an identifier prefixed with # (the hash symbol). The hash is an integral part of the field's name, which means a private field can never have name clash with a public field or method. In order to refer to a private field anywhere in the class, you must declare it in the class body (you can't create a private element on the fly). Apart from this, a private field is pretty much equivalent to a normal property. js class Color {\n  // Declare: every Color instance has a private field called #values.\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  getRed() {\n    return this.#values[0];\n  }\n  setRed(value) {\n    this.#values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconsole.log(red.getRed()); // 255 Accessing private fields outside the class is an early syntax error. The language can guard against this because #privateField is a special syntax, so it can do some static analysis and find all usage of private fields before even evaluating the code. js console.log(red.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class Note: Code run in the Chrome console can access private elements outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction. Private fields in JavaScript are hard private : if the class does not implement methods that expose these private fields, there's absolutely no mechanism to retrieve them from outside the class. This means you are safe to do any refactors to your class's private fields, as long as the behavior of exposed methods stay the same. After we've made the values field private, we can add some more logic in the getRed and setRed methods, instead of making them simple pass-through methods. For example, we can add a check in setRed to see if it's a valid R value: js class Color {\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  getRed() {\n    return this.#values[0];\n  }\n  setRed(value) {\n    if (value < 0 || value > 255) {\n      throw new RangeError(\"Invalid R value\");\n    }\n    this.#values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.setRed(1000); // RangeError: Invalid R value If we leave the values property exposed, our users can easily circumvent that check by assigning to values[0] directly, and create invalid colors. But with a well-encapsulated API, we can make our code more robust and prevent logic errors downstream. A class method can read the private fields of other instances, as long as they belong to the same class. js class Color {\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  redDifference(anotherColor) {\n    // #values doesn't necessarily need to be accessed from this:\n    // you can access private fields of other instances belonging\n    // to the same class.\n    return this.#values[0] - anotherColor.#values[0];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nconst crimson = new Color(220, 20, 60);\nred.redDifference(crimson); // 35 However, if anotherColor is not a Color instance, #values won't exist. (Even if another class has an identically named #values private field, it's not referring to the same thing and cannot be accessed here.) Accessing a nonexistent private element throws an error instead of returning undefined like normal properties do. If you don't know if a private field exists on an object and you wish to access it without using try / catch to handle the error, you can use the in operator. js class Color {\n  #values;\n  constructor(r, g, b) {\n    this.#values = [r, g, b];\n  }\n  redDifference(anotherColor) {\n    if (!(#values in anotherColor)) {\n      throw new TypeError(\"Color instance expected\");\n    }\n    return this.#values[0] - anotherColor.#values[0];\n  }\n} Note: Keep in mind that the # is a special identifier syntax, and you can't use the field name as if it's a string. \"#values\" in anotherColor would look for a property name literally called \"#values\" , instead of a private field. There are some limitations in using private elements: the same name can't be declared twice in a single class, and they can't be deleted. Both lead to early syntax errors. js class BadIdeas {\n  #firstName;\n  #firstName; // syntax error occurs here\n  #lastName;\n  constructor() {\n    delete this.#lastName; // also a syntax error\n  }\n} Methods, getters, and setters can be private as well. They're useful when you have something complex that the class needs to do internally but no other part of the code should be allowed to call. For example, imagine creating HTML custom elements that should do something somewhat complicated when clicked/tapped/otherwise activated. Furthermore, the somewhat complicated things that happen when the element is clicked should be restricted to this class, because no other part of the JavaScript will (or should) ever access it. js class Counter extends HTMLElement {\n  #xValue = 0;\n  constructor() {\n    super();\n    this.onclick = this.#clicked.bind(this);\n  }\n  get #x() {\n    return this.#xValue;\n  }\n  set #x(value) {\n    this.#xValue = value;\n    window.requestAnimationFrame(this.#render.bind(this));\n  }\n  #clicked() {\n    this.#x++;\n  }\n  #render() {\n    this.textContent = this.#x.toString();\n  }\n  connectedCallback() {\n    this.#render();\n  }\n}\n\ncustomElements.define(\"num-counter\", Counter); In this case, pretty much every field and method is private to the class. Thus, it presents an interface to the rest of the code that's essentially just like a built-in HTML element. No other part of the program has the power to affect any of the internals of Counter . Accessor fields color.getRed() and color.setRed() allow us to read and write to the red value of a color. If you come from languages like Java, you will be very familiar with this pattern. However, using methods to simply access a property is still somewhat unergonomic in JavaScript. Accessor fields allow us to manipulate something as if it is an \"actual property\". js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  get red() {\n    return this.values[0];\n  }\n  set red(value) {\n    this.values[0] = value;\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.red = 0;\nconsole.log(red.red); // 0 It looks as if the object has a property called red \u2014 but actually, no such property exists on the instance! There are only two methods, but they are prefixed with get and set , which allows them to be manipulated as if they were properties. If a field only has a getter but no setter, it will be effectively read-only. js class Color {\n  constructor(r, g, b) {\n    this.values = [r, g, b];\n  }\n  get red() {\n    return this.values[0];\n  }\n}\n\nconst red = new Color(255, 0, 0);\nred.red = 0;\nconsole.log(red.red); // 255 In strict mode , the red.red = 0 line will throw a type error: \"Cannot set property red of #<Color> which has only a getter\". In non-strict mode, the assignment is silently ignored. Public fields Private fields also have their public counterparts, which allow every instance to have a property. Fields are usually designed to be independent of the constructor's parameters. js class MyClass {\n  luckyNumber = Math.random();\n}\nconsole.log(new MyClass().luckyNumber); // 0.5\nconsole.log(new MyClass().luckyNumber); // 0.3 Public fields are almost equivalent to assigning a property to this . For example, the above example can also be converted to: js class MyClass {\n  constructor() {\n    this.luckyNumber = Math.random();\n  }\n} Static properties With the Date example, we have also encountered the Date.now() method, which returns the current date. This method does not belong to any date instance \u2014 it belongs to the class itself. However, it's put on the Date class instead of being exposed as a global DateNow() function, because it's mostly useful when dealing with date instances. Note: Prefixing utility methods with what they deal with is called \"namespacing\" and is considered a good practice. For example, in addition to the older, unprefixed parseInt() method, JavaScript also later added the prefixed Number.parseInt() method to indicate that it's for dealing with numbers. Static properties are a group of class features that are defined on the class itself, rather than on individual instances of the class. These features include: Static methods Static fields Static getters and setters Everything also has private counterparts. For example, for our Color class, we can create a static method that checks whether a given triplet is a valid RGB value: js class Color {\n  static isValid(r, g, b) {\n    return r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255;\n  }\n}\n\nColor.isValid(255, 0, 0); // true\nColor.isValid(1000, 0, 0); // false Static properties are very similar to their instance counterparts, except that: They are all prefixed with static , and They are not accessible from instances. js console.log(new Color(0, 0, 0).isValid); // undefined There is also a special construct called a static initialization block , which is a block of code that runs when the class is first loaded. js class MyClass {\n  static {\n    MyClass.myStaticProperty = \"foo\";\n  }\n}\n\nconsole.log(MyClass.myStaticProperty); // 'foo' Static initialization blocks are almost equivalent to immediately executing some code after a class has been declared. The only difference is that they have access to static private elements. Extends and inheritance A key feature that classes bring about (in addition to ergonomic encapsulation with private fields) is inheritance , which means one object can \"borrow\" a large part of another object's behaviors, while overriding or enhancing certain parts with its own logic. For example, suppose our Color class now needs to support transparency. We may be tempted to add a new field that indicates its transparency: js class Color {\n  #values;\n  constructor(r, g, b, a = 1) {\n    this.#values = [r, g, b, a];\n  }\n  get alpha() {\n    return this.#values[3];\n  }\n  set alpha(value) {\n    if (value < 0 || value > 1) {\n      throw new RangeError(\"Alpha value must be between 0 and 1\");\n    }\n    this.#values[3] = value;\n  }\n} However, this means every instance \u2014 even the vast majority which aren't transparent (those with an alpha value of 1) \u2014 will have to have the extra alpha value, which is not very elegant. Plus, if the features keep growing, our Color class will become very bloated and hard to maintain. Instead, in object-oriented programming, we would create a derived class . The derived class has access to all public properties of the parent class. In JavaScript, derived classes are declared with an extends clause, which indicates the class it extends from. js class ColorWithAlpha extends Color {\n  #alpha;\n  constructor(r, g, b, a) {\n    super(r, g, b);\n    this.#alpha = a;\n  }\n  get alpha() {\n    return this.#alpha;\n  }\n  set alpha(value) {\n    if (value < 0 || value > 1) {\n      throw new RangeError(\"Alpha value must be between 0 and 1\");\n    }\n    this.#alpha = value;\n  }\n} There are a few things that have immediately come to attention. First is that in the constructor, we are calling super(r, g, b) . It is a language requirement to call super() before accessing this . The super() call calls the parent class's constructor to initialize this \u2014 here it's roughly equivalent to this = new Color(r, g, b) . You can have code before super() , but you cannot access this before super() \u2014 the language prevents you from accessing the uninitialized this . After the parent class is done with modifying this , the derived class can do its own logic. Here we added a private field called #alpha , and also provided a pair of getter/setters to interact with them. A derived class inherits all methods from its parent. For example, consider the get red() accessor we added to the Color in the Accessor fields section\u2014even though we haven't declared one in ColorWithAlpha , we can still access red because this behavior is specified by the parent class: js const color = new ColorWithAlpha(255, 0, 0, 0.5);\nconsole.log(color.red); // 255 Derived classes can also override methods from the parent class. For example, all classes implicitly inherit the Object class, which defines some basic methods like toString() . However, the base toString() method is notoriously useless, because it prints [object Object] in most cases: js console.log(red.toString()); // [object Object] Instead, our class can override it to print the color's RGB values: js class Color {\n  #values;\n  // \u2026\n  toString() {\n    return this.#values.join(\", \");\n  }\n}\n\nconsole.log(new Color(255, 0, 0).toString()); // '255, 0, 0' Within derived classes, you can access the parent class's methods by using super . This allows you to build enhancement methods and avoid code duplication. js class ColorWithAlpha extends Color {\n  #alpha;\n  // \u2026\n  toString() {\n    // Call the parent class's toString() and build on the return value\n    return `${super.toString()}, ${this.#alpha}`;\n  }\n}\n\nconsole.log(new ColorWithAlpha(255, 0, 0, 0.5).toString()); // '255, 0, 0, 0.5' When you use extends , the static methods inherit from each other as well, so you can also override or enhance them. js class ColorWithAlpha extends Color {\n  // \u2026\n  static isValid(r, g, b, a) {\n    // Call the parent class's isValid() and build on the return value\n    return super.isValid(r, g, b) && a >= 0 && a <= 1;\n  }\n}\n\nconsole.log(ColorWithAlpha.isValid(255, 0, 0, -1)); // false Derived classes don't have access to the parent class's private fields \u2014 this is another key aspect to JavaScript private fields being \"hard private\". Private fields are scoped to the class body itself and do not grant access to any outside code. js class ColorWithAlpha extends Color {\n  log() {\n    console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class\n  }\n} A class can only extend from one class. This prevents problems in multiple inheritance like the diamond problem . However, due to the dynamic nature of JavaScript, it's still possible to achieve the effect of multiple inheritance through class composition and mixins . Instances of derived classes are also instances of the base class. js const color = new ColorWithAlpha(255, 0, 0, 0.5);\nconsole.log(color instanceof Color); // true\nconsole.log(color instanceof ColorWithAlpha); // true Why classes? The guide has been pragmatic so far: we are focusing on how classes can be used, but there's one question unanswered: why would one use a class? The answer is: it depends. Classes introduce a paradigm , or a way to organize your code. Classes are the foundations of object-oriented programming, which is built on concepts like inheritance and polymorphism (especially subtype polymorphism ). However, many people are philosophically against certain OOP practices and don't use classes as a result. For example, one thing that makes Date objects infamous is that they're mutable . js function incrementDay(date) {\n  return date.setDate(date.getDate() + 1);\n}\nconst date = new Date(); // 2019-06-19\nconst newDay = incrementDay(date);\nconsole.log(newDay); // 2019-06-20\n// The old date is modified as well!?\nconsole.log(date); // 2019-06-20 Mutability and internal state are important aspects of object-oriented programming, but often make code hard to reason with \u2014 because any seemingly innocent operation may have unexpected side effects and change the behavior in other parts of the program. In order to reuse code, we usually resort to extending classes, which can create big hierarchies of inheritance patterns. However, it is often hard to describe inheritance cleanly when one class can only extend one other class. Often, we want the behavior of multiple classes. In Java, this is done through interfaces; in JavaScript, it can be done through mixins. But at the end of the day, it's still not very convenient. On the brighter side, classes are a very powerful way to organize our code on a higher level. For example, without the Color class, we may need to create a dozen of utility functions: js function isRed(color) {\n  return color.red === 255;\n}\nfunction isValidColor(color) {\n  return (\n    color.red >= 0 &&\n    color.red <= 255 &&\n    color.green >= 0 &&\n    color.green <= 255 &&\n    color.blue >= 0 &&\n    color.blue <= 255\n  );\n}\n// \u2026 But with classes, we can congregate them all under the Color namespace, which improves readability. In addition, the introduction of private fields allows us to hide certain data from downstream users, creating a clean API. In general, you should consider using classes when you want to create objects that store their own internal data and expose a lot of behavior. Take built-in JavaScript classes as examples: The Map and Set classes store a collection of elements and allow you to access them by key using get() , set() , has() , etc. The Date class stores a date as a Unix timestamp (a number) and allows you to format, update, and read individual date components. The Error class stores information about a particular exception, including the error message, stack trace, cause, etc. It's one of the few classes that come with a rich inheritance structure: there are multiple built-in classes like TypeError and ReferenceError that extend Error . In the case of errors, this inheritance allows refining the semantics of errors: each error class represents a specific type of error, which can be easily checked with instanceof . JavaScript offers the mechanism to organize your code in a canonical object-oriented way, but whether and how to use it is entirely up to the programmer's discretion. Previous Next Help improve MDN Learn how to contribute This page was last modified on \u2068Nov 24, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content"
    }
  },
  "metadata": {
    "jsonld": [],
    "microdata": [],
    "opengraph": {},
    "twitter": {
      "card": "summary_large_image",
      "creator": "MozDevNet"
    }
  },
  "timestamp": "2025-12-04T13:38:12.678386"
}