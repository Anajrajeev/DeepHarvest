{
  "url": "https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API",
  "content": {
    "text": {
      "title": "Working with the History API - Web APIs | MDN",
      "text": "Working with the History API - Web APIs | MDN Skip to main content Skip to search MDN HTML HTML: Markup language HTML reference Elements Global attributes Attributes See all\u2026 HTML guides Responsive images HTML cheatsheet Date & time formats See all\u2026 Markup languages SVG MathML XML CSS CSS: Styling language CSS reference Properties Selectors At-rules Values See all\u2026 CSS guides Box model Animations Flexbox Colors See all\u2026 Layout cookbook Column layouts Centering an element Card component See all\u2026 JavaScript JS JavaScript: Scripting language JS reference Standard built-in objects Expressions & operators Statements & declarations Functions See all\u2026 JS guides Control flow & error handing Loops and iteration Working with objects Using classes See all\u2026 Web APIs Web APIs: Programming interfaces Web API reference File system API Fetch API Geolocation API HTML DOM API Push API Service worker API See all\u2026 Web API guides Using the Web animation API Using the Fetch API Working with the History API Using the Web speech API Using web workers All All web technology Technologies Accessibility HTTP URI Web extensions WebAssembly WebDriver See all\u2026 Topics Media Performance Privacy Security Progressive web apps Learn Learn web development Frontend developer course Getting started modules Core modules MDN Curriculum Learn HTML Structuring content with HTML module Learn CSS CSS styling basics module CSS layout module Learn JavaScript Dynamic scripting with JavaScript module Tools Discover our tools Playground HTTP Observatory Border-image generator Border-radius generator Box-shadow generator Color format converter Color mixer Shape generator About Get to know MDN better About MDN Advertise with us Community MDN on GitHub Blog Web Web APIs History API Working with the History API Working with the History API The History API enables a website to interact with the browser's session history: that is, the list of pages that the user has visited in a given window. As the user visits new pages, for example by clicking links, those new pages are added to the session history. The user can also move back and forth through the history using the browser's \"Back\" and \"Forward\" buttons. The main interface defined in the History API is the History interface, and this defines two quite distinct sets of methods: Methods to navigate to a page in the session history: History.back() History.forward() History.go() Methods to modify the session history: History.pushState() History.replaceState() In this guide, we'll cover only the second set of methods. The pushState() method adds a new entry to the session history, while the replaceState() method updates the session history entry for the current page. Both these methods take a state parameter which can contain any serializable object . When the browser navigates to this history entry, the browser fires a popstate event, which contains the state object associated with that entry. The main purpose of these APIs is to support websites like Single-page applications , that use JavaScript APIs such as fetch() to update the page with new content, instead of loading a whole new page. In this article Single-page applications and session history Using pushState() Using the popstate event Using replaceState() Complete History API example See also Single-page applications and session history Traditionally, websites are implemented as a collection of pages. When users navigate to different parts of the site by clicking links, the browser loads a whole new page each time. While this is great for many sites, it can have some disadvantages: It can be inefficient to load a whole page every time, when only part of the page needs to be updated. It is hard to maintain application state when navigating across pages. For these reasons, a popular pattern for web apps is the single-page application (SPA). When a user clicks a link, the SPA performs the following steps: Prevents the default behavior of loading a new page. Fetches new content to display. Updates the page with the new content. For example: js document.addEventListener(\"click\", async (event) => {\n  const creature = event.target.getAttribute(\"data-creature\");\n  if (creature) {\n    // Prevent a new page from loading\n    event.preventDefault();\n    try {\n      // Fetch new content\n      const response = await fetch(`creatures/${creature}.json`);\n      const result = await response.json();\n      // Update the page with the new content\n      displayContent(result);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}); In this click handler, if the link contains a data attribute \"data-creature\" , then we use the value of that attribute to fetch a JSON file containing the new content for the page. The JSON file might look like this: json {\n  \"description\": \"Bald eagles are not actually bald.\",\n  \"image\": {\n    \"src\": \"images/eagle.jpg\",\n    \"alt\": \"A bald eagle\"\n  },\n  \"name\": \"Eagle\"\n} Our displayContent() function updates the page with the JSON: js // Update the page with the new content\nfunction displayContent(content) {\n  document.title = `Creatures: ${content.name}`;\n\n  const description = document.querySelector(\"#description\");\n  description.textContent = content.description;\n\n  const photo = document.querySelector(\"#photo\");\n  photo.setAttribute(\"src\", content.image.src);\n  photo.setAttribute(\"alt\", content.image.alt);\n} The problem is that it breaks the expected behavior of the browser's \"Back\" and \"Forward\" buttons. From the user's point of view, they clicked a link and the page updated, so it looks like a new page. If they then press the browser's \"Back\" button, they expect to go to the state before they clicked the link. But as far as the browser is concerned, the last link didn't load a new page, so \"Back\" will take the browser to whichever page was loaded before the user opened the SPA. This is essentially the problem that pushState() , replaceState() , and the popstate event solve. They enable us to synthesize history entries, and to be notified when the current session history entry changes to one of these entries (for example, because the user pressed the \"Back\" or \"Forward\" buttons). Using pushState() We can add a history entry to the click handler above as follows: js document.addEventListener(\"click\", async (event) => {\n  const creature = event.target.getAttribute(\"data-creature\");\n  if (creature) {\n    event.preventDefault();\n    try {\n      const response = await fetch(`creatures/${creature}.json`);\n      const result = await response.json();\n      displayContent(result);\n      // Add a new entry to the history.\n      // This simulates loading a new page.\n      history.pushState(result, \"\", creature);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}); Here, we're calling pushState() with three arguments: result : This is the content we just fetched. It will be stored with the history entry, and later included as the state property of the argument passed to the popstate event handler. \"\" : This is needed for backward compatibility with legacy sites, and should always be an empty string. creature : This will be used as the URL for the entry. It will be shown in the browser's URL bar, and will be used as the value of the Referer header in any HTTP requests that the page makes. Note that this must be same-origin with the page. Using the popstate event Suppose the user performs the following steps: Clicks a link in our SPA, so we update the page and add history entry A using pushState() . Clicks another link in our SPA, so we update the page and add history entry B using pushState() . Presses the \"Back\" button. Now the new current history entry is A, so the browser fires the popstate event, and the event handler argument includes the JSON that we passed to pushState() when we handled the navigation to A. This means we can restore the correct content with an event handler like this: js // Handle forward/back buttons\nwindow.addEventListener(\"popstate\", (event) => {\n  // If a state has been provided, we have a \"simulated\" page\n  // and we update the current page.\n  if (event.state) {\n    // Simulate the loading of the previous page\n    displayContent(event.state);\n  }\n}); Using replaceState() There's one more piece we need to add. When the user loads the SPA, the browser adds a history entry. Because this was an actual page load, the entry has no state associated with it. So suppose the user does the following: Loads the SPA, so the browser adds a history entry. Clicks a link inside the SPA, so the click handler updates the page and adds a history entry with pushState() . Presses the \"Back\" button. Now we want to go back to the SPA's initial state, but since this is a navigation in the same document, the page will not be reloaded, and since the history entry for the initial page has no state, we can't use popstate to restore it. The solution here is to use replaceState() to set the state object for the initial page. For example: js // Create state on page load and replace the current history with it\nconst image = document.querySelector(\"#photo\");\nconst initialState = {\n  description: document.querySelector(\"#description\").textContent,\n  image: {\n    src: image.getAttribute(\"src\"),\n    alt: image.getAttribute(\"alt\"),\n  },\n  name: \"Home\",\n};\nhistory.replaceState(initialState, \"\", document.location.href); On page load, we collect all the parts of the page that we need to restore when the user returns to the starting point for the SPA. This has the same structure as the JSON we fetch when handling other navigations. We pass this initialState object into replaceState() , which effectively adds the state object to the current history entry. When the user returns to our starting point, the popstate event will contain this initial state, and we can use our displayContent() function to update the page. Complete History API example You can find this complete example at https://github.com/mdn/dom-examples/tree/main/history-api , and see the demo live at https://mdn.github.io/dom-examples/history-api/ . See also History API history global object Help improve MDN Learn how to contribute This page was last modified on \u2068Aug 1, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content History API Guides Working with the History API Interfaces History PopStateEvent Properties Window .history Events Window: popstate Your blueprint for a better internet. MDN About Blog Mozilla careers Advertise with us MDN Plus Product help Contribute MDN Community Community resources Writing guidelines MDN Discord MDN on GitHub Developers Web technologies Learn web development Guides Tutorials Glossary Hacks blog Website Privacy Notice Telemetry Settings Legal Community Participation Guidelines Visit Mozilla Corporation\u2019s not-for-profit parent, the Mozilla Foundation . Portions of this content are \u00a91998\u2013\u20682025\u2069 by individual mozilla.org contributors. Content available under a Creative Commons license .",
      "meta": {
        "viewport": "width=device-width, initial-scale=1.0",
        "description": "The History API enables a website to interact with the browser's session history: that is, the list of pages that the user has visited in a given window. As the user visits new pages, for example by clicking links, those new pages are added to the session history. The user can also move back and forth through the history using the browser's \"Back\" and \"Forward\" buttons.",
        "og:url": "https://developer.mozilla.org/en-US/docs/Web/API/History_API/Working_with_the_History_API",
        "og:title": "Working with the History API - Web APIs | MDN",
        "og:locale": "en_US",
        "og:description": "The History API enables a website to interact with the browser's session history: that is, the list of pages that the user has visited in a given window. As the user visits new pages, for example by clicking links, those new pages are added to the session history. The user can also move back and forth through the history using the browser's \"Back\" and \"Forward\" buttons.",
        "og:image": "https://developer.mozilla.org/mdn-social-share.d893525a4fb5fb1f67a2.png",
        "og:image:type": "image/png",
        "og:image:height": "1080",
        "og:image:width": "1920",
        "og:image:alt": "The MDN Web Docs logo, featuring a blue accent color, displayed on a solid black background.",
        "og:site_name": "MDN Web Docs",
        "twitter:card": "summary_large_image",
        "twitter:creator": "MozDevNet",
        "position": "4"
      },
      "keywords": [],
      "language": "en",
      "word_count": 1676,
      "description": "The History API enables a website to interact with the browser's session history: that is, the list of pages that the user has visited in a given window. As the user visits new pages, for example by clicking links, those new pages are added to the session history. The user can also move back and forth through the history using the browser's \"Back\" and \"Forward\" buttons.",
      "clean_text": "Working with the History API The History API enables a website to interact with the browser's session history: that is, the list of pages that the user has visited in a given window. As the user visits new pages, for example by clicking links, those new pages are added to the session history. The user can also move back and forth through the history using the browser's \"Back\" and \"Forward\" buttons. The main interface defined in the History API is the History interface, and this defines two quite distinct sets of methods: Methods to navigate to a page in the session history: History.back() History.forward() History.go() Methods to modify the session history: History.pushState() History.replaceState() In this guide, we'll cover only the second set of methods. The pushState() method adds a new entry to the session history, while the replaceState() method updates the session history entry for the current page. Both these methods take a state parameter which can contain any serializable object . When the browser navigates to this history entry, the browser fires a popstate event, which contains the state object associated with that entry. The main purpose of these APIs is to support websites like Single-page applications , that use JavaScript APIs such as fetch() to update the page with new content, instead of loading a whole new page. In this article Single-page applications and session history Using pushState() Using the popstate event Using replaceState() Complete History API example See also Single-page applications and session history Traditionally, websites are implemented as a collection of pages. When users navigate to different parts of the site by clicking links, the browser loads a whole new page each time. While this is great for many sites, it can have some disadvantages: It can be inefficient to load a whole page every time, when only part of the page needs to be updated. It is hard to maintain application state when navigating across pages. For these reasons, a popular pattern for web apps is the single-page application (SPA). When a user clicks a link, the SPA performs the following steps: Prevents the default behavior of loading a new page. Fetches new content to display. Updates the page with the new content. For example: js document.addEventListener(\"click\", async (event) => {\n  const creature = event.target.getAttribute(\"data-creature\");\n  if (creature) {\n    // Prevent a new page from loading\n    event.preventDefault();\n    try {\n      // Fetch new content\n      const response = await fetch(`creatures/${creature}.json`);\n      const result = await response.json();\n      // Update the page with the new content\n      displayContent(result);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}); In this click handler, if the link contains a data attribute \"data-creature\" , then we use the value of that attribute to fetch a JSON file containing the new content for the page. The JSON file might look like this: json {\n  \"description\": \"Bald eagles are not actually bald.\",\n  \"image\": {\n    \"src\": \"images/eagle.jpg\",\n    \"alt\": \"A bald eagle\"\n  },\n  \"name\": \"Eagle\"\n} Our displayContent() function updates the page with the JSON: js // Update the page with the new content\nfunction displayContent(content) {\n  document.title = `Creatures: ${content.name}`;\n\n  const description = document.querySelector(\"#description\");\n  description.textContent = content.description;\n\n  const photo = document.querySelector(\"#photo\");\n  photo.setAttribute(\"src\", content.image.src);\n  photo.setAttribute(\"alt\", content.image.alt);\n} The problem is that it breaks the expected behavior of the browser's \"Back\" and \"Forward\" buttons. From the user's point of view, they clicked a link and the page updated, so it looks like a new page. If they then press the browser's \"Back\" button, they expect to go to the state before they clicked the link. But as far as the browser is concerned, the last link didn't load a new page, so \"Back\" will take the browser to whichever page was loaded before the user opened the SPA. This is essentially the problem that pushState() , replaceState() , and the popstate event solve. They enable us to synthesize history entries, and to be notified when the current session history entry changes to one of these entries (for example, because the user pressed the \"Back\" or \"Forward\" buttons). Using pushState() We can add a history entry to the click handler above as follows: js document.addEventListener(\"click\", async (event) => {\n  const creature = event.target.getAttribute(\"data-creature\");\n  if (creature) {\n    event.preventDefault();\n    try {\n      const response = await fetch(`creatures/${creature}.json`);\n      const result = await response.json();\n      displayContent(result);\n      // Add a new entry to the history.\n      // This simulates loading a new page.\n      history.pushState(result, \"\", creature);\n    } catch (err) {\n      console.error(err);\n    }\n  }\n}); Here, we're calling pushState() with three arguments: result : This is the content we just fetched. It will be stored with the history entry, and later included as the state property of the argument passed to the popstate event handler. \"\" : This is needed for backward compatibility with legacy sites, and should always be an empty string. creature : This will be used as the URL for the entry. It will be shown in the browser's URL bar, and will be used as the value of the Referer header in any HTTP requests that the page makes. Note that this must be same-origin with the page. Using the popstate event Suppose the user performs the following steps: Clicks a link in our SPA, so we update the page and add history entry A using pushState() . Clicks another link in our SPA, so we update the page and add history entry B using pushState() . Presses the \"Back\" button. Now the new current history entry is A, so the browser fires the popstate event, and the event handler argument includes the JSON that we passed to pushState() when we handled the navigation to A. This means we can restore the correct content with an event handler like this: js // Handle forward/back buttons\nwindow.addEventListener(\"popstate\", (event) => {\n  // If a state has been provided, we have a \"simulated\" page\n  // and we update the current page.\n  if (event.state) {\n    // Simulate the loading of the previous page\n    displayContent(event.state);\n  }\n}); Using replaceState() There's one more piece we need to add. When the user loads the SPA, the browser adds a history entry. Because this was an actual page load, the entry has no state associated with it. So suppose the user does the following: Loads the SPA, so the browser adds a history entry. Clicks a link inside the SPA, so the click handler updates the page and adds a history entry with pushState() . Presses the \"Back\" button. Now we want to go back to the SPA's initial state, but since this is a navigation in the same document, the page will not be reloaded, and since the history entry for the initial page has no state, we can't use popstate to restore it. The solution here is to use replaceState() to set the state object for the initial page. For example: js // Create state on page load and replace the current history with it\nconst image = document.querySelector(\"#photo\");\nconst initialState = {\n  description: document.querySelector(\"#description\").textContent,\n  image: {\n    src: image.getAttribute(\"src\"),\n    alt: image.getAttribute(\"alt\"),\n  },\n  name: \"Home\",\n};\nhistory.replaceState(initialState, \"\", document.location.href); On page load, we collect all the parts of the page that we need to restore when the user returns to the starting point for the SPA. This has the same structure as the JSON we fetch when handling other navigations. We pass this initialState object into replaceState() , which effectively adds the state object to the current history entry. When the user returns to our starting point, the popstate event will contain this initial state, and we can use our displayContent() function to update the page. Complete History API example You can find this complete example at https://github.com/mdn/dom-examples/tree/main/history-api , and see the demo live at https://mdn.github.io/dom-examples/history-api/ . See also History API history global object Help improve MDN Learn how to contribute This page was last modified on \u2068Aug 1, 2025\u2069 by MDN contributors . View this page on GitHub \u2022 Report a problem with this content"
    }
  },
  "metadata": {
    "jsonld": [],
    "microdata": [],
    "opengraph": {},
    "twitter": {
      "card": "summary_large_image",
      "creator": "MozDevNet"
    }
  },
  "timestamp": "2025-12-04T13:38:18.230679"
}